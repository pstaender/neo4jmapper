<!DOCTYPE html>

<html>
<head>
  <title>node.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="graph.html">
                graph.js
              </a>
            
              
              <a class="source" href="helpers.html">
                helpers.js
              </a>
            
              
              <a class="source" href="index.html">
                index.js
              </a>
            
              
              <a class="source" href="neo4jrestful.html">
                neo4jrestful.js
              </a>
            
              
              <a class="source" href="node.html">
                node.js
              </a>
            
              
              <a class="source" href="path.html">
                path.js
              </a>
            
              
              <a class="source" href="relationship.html">
                relationship.js
              </a>
            
              
              <a class="source" href="transaction.html">
                transaction.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>node.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h2>Node Object</h2>
<p>The Node object is to create, connect and query all kind of Node(s).
You can register your own model</p>
<p>Requirements (for browser and nodejs):
<em> neo4jmapper helpers
</em> underscorejs
* sequence (<a href="https://github.com/coolaj86/futures">https://github.com/coolaj86/futures</a>)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> __initNode__ = <span class="keyword">function</span>(neo4jrestful, Graph) {

  <span class="keyword">var</span> helpers = <span class="literal">null</span>;
  <span class="keyword">var</span> _ = <span class="literal">null</span>;
  <span class="keyword">var</span> Sequence = <span class="literal">null</span>;

  <span class="keyword">if</span> (<span class="keyword">typeof</span> window === <span class="string">'object'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>browser
TODO: find a solution for bson object id</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    helpers      = window.Neo4jMapper.helpers;
    _            = window._;
    Sequence     = window.Sequence;
  } <span class="keyword">else</span> {
    helpers      = require(<span class="string">'./helpers'</span>);
    _            = require(<span class="string">'underscore'</span>);
    Sequence     = require(<span class="string">'./lib/sequence'</span>);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h3>Constructor of Node</h3>
<p>calls this.init(data,id) to set all values to default</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> Node = <span class="function"><span class="keyword">function</span> <span class="title">Node</span><span class="params">(data, id)</span> {</span>
    <span class="keyword">var</span> cb = <span class="literal">null</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>id can be a callback as well</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (<span class="keyword">typeof</span> id === <span class="string">'function'</span>) {
      cb = id;
      id = <span class="literal">undefined</span>;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>will be used for labels and classes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (!<span class="keyword">this</span>._constructor_name_)
      <span class="keyword">this</span>._constructor_name_ = helpers.constructorNameOfFunction(<span class="keyword">this</span>) || <span class="string">'Node'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>each node object has it&#39;s own restful client</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">this</span>.init(data, id);
    <span class="keyword">if</span> (cb)
      <span class="keyword">return</span> <span class="keyword">this</span>.save(cb);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h3>Initialize all values on node object</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Node.prototype.init = <span class="keyword">function</span>(data, id) {
    <span class="keyword">this</span>.id = id || <span class="literal">null</span>;
    <span class="keyword">this</span>.data = _.extend({}, data);
    <span class="keyword">this</span>.resetQuery();
    <span class="keyword">if</span> (id) {
      <span class="keyword">this</span>.setUriById(id);
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>nested objects must be extended nestedly</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">this</span>.fields = _.extend({}, {
      defaults: _.extend({}, <span class="keyword">this</span>.fields.defaults),
      indexes: _.extend({}, <span class="keyword">this</span>.fields.indexes),
      unique: _.extend({}, <span class="keyword">this</span>.fields.unique)
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>copy array</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">this</span>.labels = _.uniq(<span class="keyword">this</span>.labels);

    <span class="keyword">this</span>._is_instanced_ = <span class="literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>we will use a label by default if we have defined an inherited class of node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> ((<span class="keyword">this</span>._constructor_name_ !== <span class="string">'Node'</span>)&amp;&amp;(<span class="keyword">this</span>._constructor_name_ !== <span class="string">'Relationship'</span>)&amp;&amp;(<span class="keyword">this</span>._constructor_name_ !== <span class="string">'Path'</span>)) {
      <span class="keyword">this</span>.label = <span class="keyword">this</span>.cypher.label = <span class="keyword">this</span>._constructor_name_;
    }
    <span class="keyword">if</span> (!<span class="keyword">this</span>.label)
      <span class="keyword">this</span>.label = <span class="literal">null</span>;
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <h3>Instantiate a node from a specific model</h3>
<p>Model can be a constructor() or a String
and must be registered in Node.registered_models()</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Node.prototype.convertNodeToModel = <span class="keyword">function</span>(node, model, fallbackModel) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> node !== <span class="string">'object'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>we assume that we have ”model, fallbackmodel” as arguments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      fallbackmodel = model;
      model = node;
      node = <span class="keyword">this</span>;
    }
    <span class="keyword">if</span> ((<span class="keyword">typeof</span> node === <span class="string">'object'</span>) &amp;&amp; (node !== <span class="literal">null</span>)) {
      <span class="keyword">if</span> (<span class="keyword">typeof</span> fallbackModel !== <span class="string">'function'</span>)
        fallbackModel = <span class="keyword">this</span>.constructor;
      <span class="keyword">if</span> (<span class="keyword">typeof</span> model === <span class="string">'string'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>do nothing</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        model = model;
      } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> model === <span class="string">'function'</span>) {
        model = model._constructor_name_ || helpers.constructorNameOfFunction(model) || <span class="literal">null</span>;
      } <span class="keyword">else</span> <span class="keyword">if</span> (node.label) {
        model = node.label;
      } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> fallbackModel === <span class="string">'function'</span>) {
        model = helpers.constructorNameOfFunction(fallbackModel);
      } <span class="keyword">else</span> {
        <span class="keyword">throw</span> Error(<span class="string">'No model or label found'</span>)
      }
      <span class="keyword">var</span> Class = Node.registered_model(model) || fallbackModel;
      <span class="keyword">var</span> singleton = <span class="keyword">new</span> Class();
      <span class="keyword">return</span> node.copyTo(singleton);
    }
    <span class="keyword">return</span> <span class="literal">null</span>;
  }

  Node.__models__ = {};                             <span class="comment">// contains all globally registered models</span>

  Node.prototype.classification   = <span class="string">'Node'</span>;         <span class="comment">// only needed for toObject(), just for better identification of the object for the user</span>
  Node.prototype.data             = {};             <span class="comment">// will contain all data for the node</span>
  Node.prototype.id               = <span class="literal">null</span>;           <span class="comment">// ”public“ id attribute</span>
  Node.prototype._id_             = <span class="literal">null</span>;           <span class="comment">// ”private“ id attribute (to ensure that this.id deosn't get manipulated accidently)</span></pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>can be used to define schema-like-behavior
TODO: implement unique</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Node.prototype.fields = {
    defaults: {},
    indexes: {},
    unique: {}
  };

  Node.prototype.uri              = <span class="literal">null</span>;           <span class="comment">// uri of the node</span>
  Node.prototype._response_       = <span class="literal">null</span>;           <span class="comment">// original response object</span>
  Node.prototype._query_history_  = <span class="literal">null</span>;           <span class="comment">// an array that contains all query actions chronologically, is also a flag for a modified query</span>
  Node.prototype._stream_         = <span class="literal">null</span>;           <span class="comment">// flag for processing result data</span>
  Node.prototype._hashedData_     = <span class="literal">null</span>;           <span class="comment">// contains md5 hash of a persisted object</span></pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>cypher property will be <strong>copied</strong> on each new objects node.cypher in resetQuery()</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Node.prototype.cypher = {
    limit: <span class="string">''</span>,              <span class="comment">// Number</span>
    skip: <span class="string">''</span>,               <span class="comment">// Number</span>
    filter: <span class="string">''</span>,             <span class="comment">// `FILTER`   statement</span>
    match: <span class="literal">null</span>,            <span class="comment">// `MATCH`    statement</span>
    start: <span class="literal">null</span>,            <span class="comment">// `START`    statement</span>
    set: <span class="string">''</span>,                <span class="comment">// `SET`      statement</span>
    With: <span class="literal">null</span>,             <span class="comment">// `WITH`     statement</span>
    distinct: <span class="literal">null</span>,         <span class="comment">// `DISTINCT` option</span>
    return_properties: [],  <span class="comment">// [a|b|n|r|p], will be joined with `, `</span>
    where: [],              <span class="comment">// `WHERE`  statements, will be joined with `AND`</span>
    hasProperty: [],
    from: <span class="literal">null</span>,             <span class="comment">// Number</span>
    to: <span class="literal">null</span>,               <span class="comment">// Number</span>
    direction: <span class="literal">null</span>,        <span class="comment">// (incoming|outgoing|all)</span>
    order_by: <span class="string">''</span>,           <span class="comment">// $property</span>
    order_direction: <span class="string">''</span>,    <span class="comment">// (ASC|DESC)</span>
    relationship: <span class="string">''</span>,       <span class="comment">// String</span>
    outgoing: <span class="literal">null</span>,         <span class="comment">// Boolean</span>
    incoming: <span class="literal">null</span>,         <span class="comment">// Boolean</span>
    label: <span class="literal">null</span>,            <span class="comment">// String</span>
    node_identifier: <span class="literal">null</span>,  <span class="comment">// [a|b|n]</span>
    parameters: <span class="literal">null</span>,       <span class="comment">// object that contains all parameters for query</span>
    count: <span class="string">''</span>,              <span class="comment">// count(n) (DISTINCT)</span></pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Boolean flags</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _useParameters: <span class="literal">true</span>,
    _count: <span class="literal">null</span>,
    _distinct: <span class="literal">null</span>,
    _update: <span class="literal">null</span>,          <span class="comment">// flag when an update is performed</span>
    by_id: <span class="literal">null</span>
  };

  Node.prototype._is_instanced_           = <span class="literal">null</span>;   <span class="comment">// flag that this object is instanced</span>
  Node.prototype._is_singleton_           = <span class="literal">false</span>;  <span class="comment">// flag that this object is a singleton</span>
  Node.prototype._is_loaded_              = <span class="literal">null</span>;

  Node.prototype.labels                   = <span class="literal">null</span>;   <span class="comment">// an array of all labels</span>
  Node.prototype.label                    = <span class="literal">null</span>;   <span class="comment">// will be set with a label a) if only one label exists b) if one label matches to model</span>

  Node.prototype._constructor_name_       = <span class="literal">null</span>;   <span class="comment">// will be with the name of the function of the constructor</span>
  Node.prototype._load_hook_reference_    = <span class="literal">null</span>;   <span class="comment">// a reference to acticate or deactivate the load hook</span>

  Node.prototype.__already_initialized__  = <span class="literal">false</span>;  <span class="comment">// flag to avoid many initializations of a model</span></pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>should <strong>never</strong> be changed
it&#39;s used to dictinct nodes and relationships
many queries containg <code>node()</code> command will use this value
e.g. n = node(*)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Node.prototype.__TYPE__                 = <span class="string">'node'</span>;
  Node.prototype.__TYPE_IDENTIFIER__      = <span class="string">'n'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <h3>Create a singleton</h3>
<p>Here a singleton is a node object that is used as
a placeholder to use all <code>static</code> methods on the node object.
To avoid conflicts on async usage, each singleton is it&#39;s own instance
Example Usage: <code>Node.singleton().findOne().where()</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Node.prototype.singleton = <span class="keyword">function</span>(id, label) {
    <span class="keyword">var</span> Class = <span class="keyword">this</span>.constructor;
    <span class="keyword">var</span> node = <span class="keyword">new</span> Class({},id);
    <span class="keyword">if</span> (<span class="keyword">typeof</span> label === <span class="string">'string'</span>)
      node.label = label;
    node.resetQuery();
    node._is_singleton_ = <span class="literal">true</span>;
    node.resetQuery();
    <span class="keyword">return</span> node;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <h3>Initializes the model</h3>
<p>Calls the onBeforeInitialize &amp; onAfterInitialize hook
The callback can be used to ensure that all async processes are finished</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Node.prototype.initialize = <span class="keyword">function</span>(cb) {
    <span class="keyword">var</span> self = <span class="keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>here a callback is optional</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (<span class="keyword">typeof</span> cb !== <span class="string">'function'</span>)
      cb = <span class="keyword">function</span>() { <span class="comment">/* /dev/null */</span> };
    <span class="keyword">if</span> (!<span class="keyword">this</span>.__already_initialized__) {
      <span class="keyword">return</span> <span class="keyword">this</span>.onBeforeInitialize(<span class="keyword">function</span>(err) {
        <span class="keyword">if</span> (err)
          cb(err, <span class="literal">null</span>);
        <span class="keyword">else</span>
          self.onAfterInitialize(cb);
      });
    } <span class="keyword">else</span> {
      <span class="keyword">return</span> cb(<span class="literal">null</span>, <span class="keyword">this</span>.constructor);
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <h3>Hook: onBeforeInitialize</h3>
<p>Can be monkey-pacthed and be used to execute code
on prototype base during registering a model
HINT: call the cb() finnaly</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Node.prototype.onBeforeInitialize = <span class="keyword">function</span>(next) {
    <span class="keyword">return</span> next(<span class="literal">null</span>,<span class="literal">null</span>);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <h3>Internal Hook: onAfterInitialize</h3>
<p>Ensures autoindex on the label</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Node.prototype.onAfterInitialize = <span class="keyword">function</span>(cb) {</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>here we return the constructor as 2nd argument in cb
because it is expected at <code>Node.register_model(&#39;Label&#39;, cb)</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="keyword">this</span>.__already_initialized__ = <span class="literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Index fields</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> fieldsToIndex = <span class="keyword">this</span>.fieldsForAutoindex();</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>we create an object to get the label</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> node = <span class="keyword">new</span> <span class="keyword">this</span>.constructor();
    <span class="keyword">var</span> label = node.label;
    <span class="keyword">if</span> (label) {
      <span class="keyword">if</span> (fieldsToIndex.length &gt; <span class="number">0</span>) {
        <span class="keyword">return</span> node.ensureIndex({ label: label, fields: fieldsToIndex }, <span class="keyword">function</span>(err) {
          cb(err, self.constructor);
        });
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> cb(<span class="literal">null</span>, self.constructor);
      }
    } <span class="keyword">else</span> {
      <span class="keyword">return</span> cb(Error(<span class="string">'No label found'</span>), <span class="keyword">this</span>.constructor);
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Copys only the node&#39;s relevant data(s) to another object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Node.prototype.copyTo = <span class="keyword">function</span>(n) {
    n.id = n._id_ = <span class="keyword">this</span>._id_;
    n.data   = _.extend(<span class="keyword">this</span>.data);
    n.labels = _.clone(<span class="keyword">this</span>.labels);
    <span class="keyword">if</span> (<span class="keyword">this</span>.label)
      n.label  = <span class="keyword">this</span>.label;
    n.uri = <span class="keyword">this</span>.uri;
    n._response_ = _.extend(<span class="keyword">this</span>._response_);
    <span class="keyword">return</span> n;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Resets the query <strong>but</strong> should not be used since you should start from Node.… instead
Anyhow, e.g.:</p>
<p>n = Node.findOne().where(cb)
n.resetQuery().findOne(otherCb)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Node.prototype.resetQuery = <span class="keyword">function</span>() {</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>we have to copy the cypher values on each object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">this</span>.cypher = {};
    _.extend(<span class="keyword">this</span>.cypher, <span class="keyword">this</span>.constructor.prototype.cypher);
    <span class="keyword">this</span>.cypher.where = [];
    <span class="keyword">this</span>.cypher.hasProperty = [];
    <span class="keyword">this</span>.cypher.match = [];
    <span class="keyword">this</span>.cypher.return_properties = [];
    <span class="keyword">this</span>.cypher.start = {};
    <span class="keyword">this</span>._query_history_ = [];
    <span class="keyword">if</span> (<span class="keyword">this</span>.id)
      <span class="keyword">this</span>.cypher.from = <span class="keyword">this</span>.id;
    <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// return self for chaining</span>
  }

  Node.prototype.hasId = <span class="keyword">function</span>() {
    <span class="keyword">return</span> ((<span class="keyword">this</span>._is_instanced_) &amp;&amp; (_.isNumber(<span class="keyword">this</span>._id_))) ? <span class="literal">true</span> : <span class="literal">false</span>;
  }

  Node.prototype.setUriById = <span class="keyword">function</span>(id) {
    <span class="keyword">if</span> (_.isNumber(id))
      <span class="keyword">this</span>.uri = Graph.request().absoluteUrl(<span class="keyword">this</span>.__TYPE__+<span class="string">'/'</span>+id);
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  Node.prototype.flattenData = <span class="keyword">function</span>(useReference) {</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>strongly recommend not to mutate attached node&#39;s data</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (<span class="keyword">typeof</span> useReference !== <span class="string">'boolean'</span>)
      useReference = <span class="literal">false</span>;
    <span class="keyword">if</span> ((<span class="keyword">typeof</span> <span class="keyword">this</span>.data === <span class="string">'object'</span>) &amp;&amp; (<span class="keyword">this</span>.data !== <span class="literal">null</span>)) {
      <span class="keyword">var</span> data = (useReference) ? <span class="keyword">this</span>.data : _.extend(<span class="keyword">this</span>.data);
      data = helpers.flattenObject(data);</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>remove null values since neo4j can&#39;t store them</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> data) {
        <span class="keyword">if</span> ((<span class="keyword">typeof</span> data[key] === <span class="string">'undefined'</span>) || (data[key]===<span class="literal">null</span>))
          <span class="keyword">delete</span> data[key];
      }
      <span class="keyword">return</span> data;
    }
    <span class="keyword">return</span> <span class="keyword">this</span>.data;
  }

  Node.prototype.unflattenData = <span class="keyword">function</span>(useReference) {</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>strongly recommend not to mutate attached node&#39;s data</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (<span class="keyword">typeof</span> useReference !== <span class="string">'boolean'</span>)
      useReference = <span class="literal">false</span>;
    <span class="keyword">var</span> data = (useReference) ? <span class="keyword">this</span>.data : _.extend(<span class="keyword">this</span>.data);
    <span class="keyword">return</span> helpers.unflattenObject(data);
  }

  Node.prototype.hasValidData = <span class="keyword">function</span>() {
    <span class="keyword">return</span> helpers.isValidData(<span class="keyword">this</span>.data);
  }

  Node.prototype.applyDefaultValues = <span class="keyword">function</span>() {</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>flatten data and defaults</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> data     = helpers.flattenObject(<span class="keyword">this</span>.data);
    <span class="keyword">var</span> defaults = helpers.flattenObject(<span class="keyword">this</span>.fields.defaults);
    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> defaults) {
      <span class="keyword">if</span> (((<span class="keyword">typeof</span> data[key] === <span class="string">'undefined'</span>)||(data[key] === <span class="literal">null</span>))&amp;&amp;(<span class="keyword">typeof</span> defaults[key] !== <span class="string">'undefined'</span>))</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>set a default value by defined function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> (<span class="keyword">typeof</span> defaults[key] === <span class="string">'function'</span>)
          data[key] = defaults[key](<span class="keyword">this</span>);
        <span class="keyword">else</span>
          data[key] = defaults[key];
    }
    <span class="keyword">this</span>.data = helpers.unflattenObject(data);
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  Node.prototype.hasFieldsToIndex = <span class="keyword">function</span>() {
    <span class="keyword">if</span> (<span class="keyword">this</span>.hasId())
      <span class="keyword">return</span> _.keys(<span class="keyword">this</span>.fields.indexes).length;
    <span class="keyword">else</span>
      <span class="keyword">return</span> <span class="literal">null</span>;
  }

  Node.prototype.fieldsToIndex = <span class="keyword">function</span>() {
    <span class="keyword">return</span> ( (<span class="keyword">this</span>.fields.indexes) &amp;&amp; (_.keys(<span class="keyword">this</span>.fields.indexes).length &gt; <span class="number">0</span>) ) ? helpers.flattenObject(<span class="keyword">this</span>.fields.indexes) : <span class="literal">null</span>;
  }

  Node.prototype.fieldsToIndexUnique = <span class="keyword">function</span>() {
    <span class="keyword">return</span> ( (<span class="keyword">this</span>.fields.unique)  &amp;&amp; (_.keys(<span class="keyword">this</span>.fields.unique).length &gt; <span class="number">0</span>) )  ? helpers.flattenObject(<span class="keyword">this</span>.fields.unique) : <span class="literal">null</span>;
  }

  Node.prototype.fieldsForAutoindex = <span class="keyword">function</span>() {</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>we merge unique and indexes fields</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> fields = <span class="keyword">this</span>.fieldsToIndex();
    <span class="keyword">var</span> keys = [];
    _.each(fields, <span class="keyword">function</span>(toBeIndexed, field) {
      <span class="keyword">if</span> (toBeIndexed === <span class="literal">true</span>)
        keys.push(field);
    });
    keys = _.uniq(_.union(keys, <span class="keyword">this</span>.uniqueFields()));
    <span class="keyword">return</span> keys;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Returns all fields that should be unique
They need to be defined in your model, e.g.:</p>
<p>Node.register_model({
 fields: {
   unique: {
     email: true
   }
}});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Node.prototype.uniqueFields = <span class="keyword">function</span>() {
    <span class="keyword">var</span> keys = [];
    _.each(<span class="keyword">this</span>.fields.unique, <span class="keyword">function</span>(isUnique, field) {
      <span class="keyword">if</span> (isUnique === <span class="literal">true</span>)
        keys.push(field);
    });
    <span class="keyword">return</span> keys;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <h1>Autoindex</h1>
<p>Check the <code>schema</code> of the model and builds an autoindex, optional with unique option
see for more details: <a href="http://docs.neo4j.org/chunked/milestone/query-constraints.html">http://docs.neo4j.org/chunked/milestone/query-constraints.html</a>
TODO: only via cypher query, to simplify process</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Node.prototype.ensureIndex = <span class="keyword">function</span>(options, cb) {
    <span class="keyword">var</span> args;
    ( ( args = helpers.sortOptionsAndCallbackArguments(options, cb) ) &amp;&amp; ( options = args.options ) &amp;&amp; ( cb = args.callback ) );
    options = _.extend({
      label: <span class="keyword">this</span>.label,                  <span class="comment">// index must be connected to a label</span>
      fields: <span class="keyword">this</span>.fieldsForAutoindex(),  <span class="comment">// fields that have to be indexed</span>
      unique: <span class="keyword">this</span>.uniqueFields() || []   <span class="comment">// fields that have be indexed as unique</span>
    }, options);
    <span class="keyword">var</span> self    = <span class="keyword">this</span>
      , keys    = _.uniq(_.union(options.fields, options.unique)) <span class="comment">// merge index + unique here</span>
      , todo    = keys.length
      , done    = <span class="number">0</span>
      , errors  = []
      , results = [];
    <span class="keyword">if</span> (!options.label)
      <span class="keyword">return</span> cb(Error(<span class="string">'Label is mandatory, you can set the label as options as well'</span>), <span class="literal">null</span>);
    <span class="keyword">var</span> url = <span class="string">'schema/index/'</span>+options.label;
    <span class="keyword">var</span> queryHead = <span class="string">"CREATE CONSTRAINT ON (n:"</span> + options.label + <span class="string">") ASSERT "</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>get all indexes fields
TODO: find a way to distinct index</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">this</span>.getIndex(<span class="keyword">function</span>(err, indexedFields) {</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>sort out fields that are already indexed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; indexedFields.length; i++) {
        keys = _.without(keys, indexedFields[i]);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>return without any arguments if there are no fields to index</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (keys.length === <span class="number">0</span>)
        <span class="keyword">return</span> cb(<span class="literal">null</span>, <span class="literal">null</span>);
      _.each(keys, <span class="keyword">function</span>(key){
        <span class="keyword">var</span> isUnique = (_.indexOf(options.unique, key) &gt;= <span class="number">0</span>);
        <span class="keyword">var</span> query = queryHead + <span class="string">"n.`"</span> + key + <span class="string">"`"</span> + ( (isUnique) ? <span class="string">" IS UNIQUE"</span> : <span class="string">""</span>)+<span class="string">";"</span>;
        <span class="keyword">var</span> after = <span class="keyword">function</span>(err, res) {
          done++;
          <span class="keyword">if</span> ((<span class="keyword">typeof</span> err === <span class="string">'object'</span>) &amp;&amp; (err !== <span class="literal">null</span>)) {
            <span class="keyword">if</span> ((err.cause) &amp;&amp; (err.cause.cause) &amp;&amp; (err.cause.cause.exception === <span class="string">'AlreadyIndexedException'</span>))</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>we ignore this &quot;error&quot;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              results.push(res);
            <span class="keyword">else</span>
              errors.push(err);
          } <span class="keyword">else</span> {
            results.push(res);
          }
          <span class="keyword">if</span> (done === todo)
            cb((errors.length &gt; <span class="number">0</span>) ? errors : <span class="literal">null</span>, results);
        };
        <span class="keyword">if</span> (isUnique)
          self.query(query, after);
        <span class="keyword">else</span>
          Graph.request().post(url, { data: { property_keys: [ key ] } }, after);
      });
    });
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  Node.prototype.dropIndex = <span class="keyword">function</span>(fields, cb) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> fields === <span class="string">'function'</span>) {
      cb = fields;
      fields = <span class="keyword">this</span>.fieldsForAutoindex();
    }
    <span class="keyword">if</span> (!<span class="keyword">this</span>.label)
      <span class="keyword">return</span> cb(Error(<span class="string">"You need to set a label on `node.label` to work with autoindex"</span>), <span class="literal">null</span>);
    <span class="keyword">var</span> todo = fields.length;
    <span class="keyword">var</span> done = <span class="number">0</span>;
    <span class="keyword">var</span> url  = <span class="string">'schema/index/'</span>+<span class="keyword">this</span>.label;</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>skip if no fields</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (todo === <span class="number">0</span>)
      <span class="keyword">return</span> cb(<span class="literal">null</span>, <span class="literal">null</span>);
    <span class="keyword">if</span> (todo===<span class="number">0</span>)
      <span class="keyword">return</span> cb(Error(<span class="string">"No fields for indexing found"</span>, <span class="literal">null</span>));
    _.each(fields, <span class="keyword">function</span>(field) {
      Graph.request().<span class="keyword">delete</span>(url+<span class="string">'/'</span>+field, <span class="keyword">function</span>(<span class="comment">/* err, res */</span>) {
        done++;
        <span class="keyword">if</span> (done === todo)
          cb(<span class="literal">null</span>, <span class="literal">null</span>);
      });
    });
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  Node.prototype.dropEntireIndex = <span class="keyword">function</span>(cb) {
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="keyword">this</span>.getIndex(<span class="keyword">function</span>(err, fields){
      <span class="keyword">if</span> (err)
        <span class="keyword">return</span> cb(err, fields);
      <span class="keyword">return</span> self.dropIndex(fields, cb);
    });
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  Node.prototype.getIndex = <span class="keyword">function</span>(cb) {
    <span class="keyword">var</span> label = <span class="keyword">this</span>.label;
    <span class="keyword">if</span> (!label)
      <span class="keyword">return</span> cb(Error(<span class="string">"You need to set a label on `node.label` to work with autoindex"</span>), <span class="literal">null</span>);
    <span class="keyword">var</span> url = <span class="string">'schema/index/'</span>+<span class="keyword">this</span>.label;
    <span class="keyword">return</span> Graph.request().get(url, <span class="keyword">function</span>(err, res){
      <span class="keyword">if</span> ((<span class="keyword">typeof</span> res === <span class="string">'object'</span>) &amp;&amp; (res !== <span class="literal">null</span>)) {
        <span class="keyword">var</span> keys = [];
        _.each(res, <span class="keyword">function</span>(data){
          <span class="keyword">if</span> (data.label === label)
            keys.push(data[<span class="string">'property-keys'</span>]);
        });
        <span class="keyword">return</span> cb(<span class="literal">null</span>, _.flatten(keys));
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> cb(err, res);
      }
    });
  }

  Node.prototype._hashData_ = <span class="keyword">function</span>() {
    <span class="keyword">if</span> (<span class="keyword">this</span>.hasValidData())
      <span class="keyword">return</span> helpers.md5(JSON.stringify(<span class="keyword">this</span>.toObject()));
    <span class="keyword">else</span>
      <span class="keyword">return</span> <span class="literal">null</span>;
  }

  Node.prototype.isPersisted = <span class="keyword">function</span>(setToTrueOrFalse) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> setToTrueOrFalse !== <span class="string">'undefined'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>use as setter</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (setToTrueOrFalse) {
        <span class="keyword">this</span>._hashedData_ = <span class="keyword">this</span>._hashData_();
      } <span class="keyword">else</span> {
        <span class="keyword">this</span>._hashedData_ = <span class="literal">null</span>;
      }
    }
    <span class="keyword">return</span> (<span class="keyword">this</span>._hashedData_) ? (<span class="keyword">this</span>._hashData_() === <span class="keyword">this</span>._hashedData_) : <span class="literal">false</span>;
  }

  Node.prototype.save = <span class="keyword">function</span>(cb) {
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="keyword">var</span> labels = (self.labels.length &gt; <span class="number">0</span>) ? self.labels : <span class="literal">null</span>;
    <span class="keyword">return</span> self.onBeforeSave(self, <span class="keyword">function</span>(err) {</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>don&#39;t execute if an error is passed through</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> ((<span class="keyword">typeof</span> err !== <span class="string">'undefined'</span>)&amp;&amp;(err !== <span class="literal">null</span>))
        cb(err, <span class="literal">null</span>);
      <span class="keyword">else</span>
        self.onSave(<span class="keyword">function</span>(err, node, debug) {</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>assign labels back</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="keyword">if</span> (labels)
            self.labels = labels;
          self.onAfterSave(err, self, cb, debug);
        });
    });
  }

  Node.prototype.onBeforeSave = <span class="keyword">function</span>(node, next) { next(<span class="literal">null</span>, <span class="literal">null</span>); }


  Node.prototype.onSave = <span class="keyword">function</span>(cb) {
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="keyword">if</span> (<span class="keyword">this</span>._is_singleton_)
      <span class="keyword">return</span> cb(Error(<span class="string">'Singleton instances can not be persisted'</span>), <span class="literal">null</span>);
    <span class="keyword">if</span> (!<span class="keyword">this</span>.hasValidData())
      <span class="keyword">return</span> cb(Error(<span class="keyword">this</span>.__TYPE__+<span class="string">' does not contain valid data. `'</span>+<span class="keyword">this</span>.__TYPE__+<span class="string">'.data` must be an object.'</span>));
    <span class="keyword">this</span>.resetQuery();
    <span class="keyword">this</span>.applyDefaultValues();

    <span class="keyword">this</span>.id = <span class="keyword">this</span>._id_;

    <span class="keyword">if</span> (<span class="keyword">this</span>.id &gt; <span class="number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>PUT / update</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      Graph.request().put(<span class="keyword">this</span>.__TYPE__+<span class="string">'/'</span>+<span class="keyword">this</span>._id_+<span class="string">'/properties'</span>, { data: <span class="keyword">this</span>.flattenData() }, <span class="keyword">function</span>(err, res, debug) {
        <span class="keyword">if</span> (err) {
          <span class="keyword">return</span> cb(err, res, debug);
        } <span class="keyword">else</span> {
          self.isPersisted(<span class="literal">true</span>);
          cb(err, self, debug);
        }
      });
    } <span class="keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>POST / create</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      Graph.request().post(<span class="keyword">this</span>.__TYPE__, { data: <span class="keyword">this</span>.flattenData() }, <span class="keyword">function</span>(err, node, debug) {
        <span class="keyword">if</span> ((err) || (!node)) {
          <span class="keyword">return</span> cb(err, node);
        } <span class="keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>copy persisted data on initially instanced node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          node.copyTo(self);
          node = self;
          node._is_singleton_ = <span class="literal">false</span>;
          node._is_instanced_ = <span class="literal">true</span>;
          <span class="keyword">if</span> (!err)
            node.isPersisted(<span class="literal">true</span>);
          <span class="keyword">return</span> cb(<span class="literal">null</span>, node, debug);
        }
      });
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>is used for Nodes + Relationships
TODO: maybe one function for node and for relationship would be a better solution (and outsource of <em>_prepareData)
Node.prototype.onSave = function(cb) {
  var self = this;
  if (this._is_singleton</em>)
    return cb(Error(&#39;Singleton instances can not be persisted&#39;), null);
  if (!this.hasValidData())
    return cb(Error(&#39;Node does not contain valid data. <code>n.data</code> must be an object.&#39;));
  this.resetQuery();
  this.applyDefaultValues();</p>
<p>  this.id = this.<em>id</em>;</p>
<p>  var data = this.flattenData();</p>
<p>  var url = null;</p>
<p>  if (this.id &gt; 0) {
    // method: PUT/UPDATE
    url = &#39;/node/properties&#39;;
    Graph.request().put(url, { data: data }, function(err, res, debug) {
      if (err) {
        return cb(err, res, debug);
      } else {
        self.isPersisted(true);
        return cb(err, self, debug);
      }
    });
  } else {
    // method: POST/CREATE
    url = this.<strong>TYPE</strong>;
    Graph.request().post(url, { data: data }, function(err, node, debug) {
      if ((err) || (!node))
        return cb(err, node, debug);
      else {
        // copy persisted data of response object <code>node</code> on source node
        node.copyTo(self);
        self.<em>is_singleton</em> = false;
        self.<em>is_instanced</em> = true;
        if (!err)
          self.isPersisted(true);
        return cb(null, self, debug);
      }
    });
  }
}</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Node.prototype.onAfterSave = <span class="keyword">function</span>(err, node, next, debug) {</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>we use labelsAsArray to avoid duplicate labels</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> labels = node.labels = node.labelsAsArray();</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>cancel if we have an error here</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (err)
      <span class="keyword">return</span> next(err, node, debug);
    <span class="keyword">if</span> (labels.length &gt; <span class="number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>we need to post the label in an extra request
cypher inappropriate since it can&#39;t handle { attributes.with.dots: &#39;value&#39; } …</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      node.addLabels(labels, <span class="keyword">function</span>(labelError, notUseableData, debugLabel) {</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>add label err if we have one</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> (labelError)
          err = labelError;</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>add debug label if we have one</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> (debug)
          debug = (debugLabel) ? [ debug, debugLabel ] : debug;
        <span class="keyword">return</span> next(err, node, debug);
      });
    } <span class="keyword">else</span> {
      <span class="keyword">return</span> next(err, node, debug);
    }
  }

  Node.prototype.update = <span class="keyword">function</span>(data, cb) {
    <span class="keyword">if</span> (!helpers.isValidData(data)) {
      cb(Error(<span class="string">'To perform an update you need to pass valid data for updating as first argument'</span>), <span class="literal">null</span>);
    }
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.hasId()) {
      <span class="keyword">if</span> (<span class="keyword">typeof</span> cb !== <span class="string">'function'</span>)
        <span class="keyword">throw</span> Error(<span class="string">'To perform an .update() on an instanced node, you have to give a cb as argument'</span>);
      <span class="keyword">this</span>.findById(<span class="keyword">this</span>._id_).update(data, cb);
      <span class="keyword">return</span> <span class="keyword">this</span>;
    } <span class="keyword">else</span> {
      data = helpers.flattenObject(data);
      <span class="keyword">this</span>.cypher.set = [];
      <span class="keyword">for</span> (<span class="keyword">var</span> attribute <span class="keyword">in</span> data) {
        <span class="keyword">this</span>.addSetDefinition(attribute, data[attribute]);
      }
    }
    <span class="keyword">this</span>.cypher.start[<span class="keyword">this</span>.__TYPE_IDENTIFIER__] =  <span class="keyword">this</span>.__TYPE__ + <span class="string">'('</span> + <span class="keyword">this</span>.cypher.by_id + <span class="string">')'</span>;
    <span class="keyword">this</span>.cypher._update = <span class="literal">true</span>;
    <span class="keyword">return</span> <span class="keyword">this</span>.exec(cb);
  }

  Node.prototype.addSetDefinition = <span class="keyword">function</span>(attribute, value) {
    <span class="keyword">if</span> (<span class="keyword">this</span>.cypher._useParameters) {
      <span class="keyword">if</span> (!<span class="keyword">this</span>.cypher.parameters)
        <span class="keyword">this</span>.cypher.parameters = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>if already parameters are added, starting with {<em>value#i</em>} instead of {<em>value0</em>}</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">var</span> parametersStartCountAt = (<span class="keyword">this</span>.cypher.parameters) ? Object.keys(<span class="keyword">this</span>.cypher.parameters).length : <span class="number">0</span>;
      <span class="keyword">var</span> key = <span class="string">'_value'</span>+parametersStartCountAt+<span class="string">'_'</span>;
      <span class="keyword">var</span> parameter = {};
      parameter[key] = value;
      <span class="keyword">this</span>.cypher.set.push(
        helpers.cypherKeyValueToString(attribute, <span class="string">'{'</span>+key+<span class="string">'}'</span>, <span class="keyword">this</span>.__TYPE_IDENTIFIER__, { valuesToParameters: <span class="literal">true</span> })
      );
      <span class="keyword">this</span>._addParameterToCypher(value);
    } <span class="keyword">else</span> {
      <span class="keyword">this</span>.cypher.set.push(helpers.cypherKeyValueToString(attribute, value, <span class="keyword">this</span>.__TYPE_IDENTIFIER__));
    }
  }

  Node.prototype.load = <span class="keyword">function</span>(cb, debug) {
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="keyword">return</span> <span class="keyword">this</span>.onBeforeLoad(self, <span class="keyword">function</span>(err, node) {
      <span class="keyword">if</span> (err)
        cb(err, node, debug);
      <span class="keyword">else</span>
        self.onAfterLoad(node, cb, debug);
    })
  }

  Node.prototype.onBeforeLoad = <span class="keyword">function</span>(node, next, debug) {
    <span class="keyword">if</span> (node.hasId()) {
      <span class="keyword">var</span> DefaultConstructor = <span class="keyword">this</span>.recommendConstructor();</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>To check that it&#39;s invoked by Noder::find() or Person::find()</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">var</span> constructorNameOfStaticMethod = <span class="keyword">this</span>.label || helpers.constructorNameOfFunction(DefaultConstructor);

      <span class="keyword">var</span> _createNodeFromLabel = <span class="keyword">function</span>(node, debug) {</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>convert node to it&#39;s model if it has a distinct label and differs from constructor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> ( (node.label) &amp;&amp; (node._constructor_name_ !== constructorNameOfStaticMethod) ) {
          node = Node.convertNodeToModel(node, node.label, DefaultConstructor);
        }
        next(<span class="literal">null</span>, node, debug);
      }

      <span class="keyword">if</span> (node._skipLoadingLabels_) {
        <span class="keyword">return</span> _createNodeFromLabel(node, debug);
      } <span class="keyword">else</span> {
        node.allLabels(<span class="keyword">function</span>(err, labels, debug) {
          <span class="keyword">if</span> (err)
            <span class="keyword">return</span> next(err, labels);
          node.setLabels(labels);
          _createNodeFromLabel(node, debug);
        });
      }
    } <span class="keyword">else</span> {
      next(<span class="literal">null</span>, node);
    }
  }

  Node.prototype.onAfterLoad = <span class="keyword">function</span>(node, next) {
    node._is_loaded_ = <span class="literal">true</span>;
    next(<span class="literal">null</span>, node);
  }

  Node.prototype.disableLoading = <span class="keyword">function</span>() {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.load === <span class="string">'function'</span>) {
      <span class="keyword">this</span>._load_hook_reference_ = <span class="keyword">this</span>.load;
      <span class="keyword">this</span>.load = <span class="literal">null</span>;
    }
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  Node.prototype.enableLoading = <span class="keyword">function</span>() {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>._load_hook_reference_ === <span class="string">'function'</span>) {
      <span class="keyword">this</span>.load = <span class="keyword">this</span>._load_hook_reference_;
      <span class="keyword">this</span>._load_hook_reference_ = <span class="literal">null</span>;
    }
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  Node.prototype.populateWithDataFromResponse = <span class="keyword">function</span>(data) {</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>if we are working on the prototype object
we won&#39;t mutate it and create a new node instance insetad</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> node;
    <span class="keyword">if</span> (!<span class="keyword">this</span>._is_instanced_)
      node = <span class="keyword">new</span> Node();
    <span class="keyword">else</span>
      node = <span class="keyword">this</span>;
    node.resetQuery();
    <span class="keyword">if</span> (data) {
      <span class="keyword">if</span> (_.isObject(data) &amp;&amp; (!_.isArray(data)))
        node._response_ = data;
      <span class="keyword">else</span>
        node._response_ = data[<span class="number">0</span>];
      node.data = node._response_.data;
      node.data = node.unflattenData();
      node.uri  = node._response_.self;</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>&#39;<a href="http://localhost:7474/db/data/node/3648">http://localhost:7474/db/data/node/3648</a>&#39;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> ((node._response_.self) &amp;&amp; (node._response_.self.match(<span class="regexp">/[0-9]+$/</span>))) {
        node.id = node._id_ = Number(node._response_.self.match(<span class="regexp">/[0-9]+$/</span>)[<span class="number">0</span>]);
      }
    }
    node.isPersisted(<span class="literal">true</span>);
    <span class="keyword">if</span> (<span class="keyword">typeof</span> node.onAfterPopulate === <span class="string">'function'</span>)
      node.onAfterPopulate();
    <span class="keyword">return</span> node;
  }

  Node.prototype.onAfterPopulate = <span class="keyword">function</span>() {
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  <span class="comment">/*
   * Query Methods (via chaining)
   */</span>

  Node.prototype.withLabel = <span class="keyword">function</span>(label, cb) {
    <span class="keyword">var</span> self = <span class="keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>return here if we have an instances node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> ( (self.hasId()) || (<span class="keyword">typeof</span> label !== <span class="string">'string'</span>) )
      <span class="keyword">return</span> self; <span class="comment">// return self for chaining</span>
    self._query_history_.push({ withLabel: label });
    self.cypher.label = label;
    <span class="keyword">return</span> self.exec(cb);
  }

  Node.prototype.shortestPathTo = <span class="keyword">function</span>(end, type, cb) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> type === <span class="string">'function'</span>) {
      cb = type;
      type = <span class="string">''</span>;
    }
    <span class="keyword">return</span> <span class="keyword">this</span>.pathBetween(<span class="keyword">this</span>, end, { <span class="string">'type'</span>: type, <span class="string">'algorithm'</span> : <span class="string">'shortestPath'</span> }, <span class="keyword">function</span>(err, result, debug){
      <span class="keyword">if</span> ((!err)&amp;&amp;(result))</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>shortestPath result has always only one result</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">return</span> cb(err, result[<span class="number">0</span>], debug);
      <span class="keyword">else</span>
        <span class="keyword">return</span> cb(err, result, debug);
    });
  }

  Node.prototype.pathBetween = <span class="keyword">function</span>(start, end, options, cb) {
    <span class="keyword">var</span> defaultOptions = {
      <span class="string">'max_depth'</span>: <span class="number">0</span>,
      <span class="string">'relationships'</span>: {
        <span class="string">'type'</span>: <span class="string">''</span>,
        <span class="string">'direction'</span>: <span class="string">'out'</span>  <span class="comment">// not in use, yet</span>
      },
      <span class="string">'algorithm'</span> : <span class="string">'shortestPath'</span>
    };
    <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">'object'</span>) {
      options = _.extend(defaultOptions, options);
    } <span class="keyword">else</span> {
      cb = options;
      options = _.extend(defaultOptions);
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>allow shorthands for easier usage</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (options.max)
      options.max_depth = options.max;
    <span class="keyword">if</span> (options.type)
      options.relationships.type = options.type;
    <span class="keyword">if</span> (options.direction)
      options.relationships.direction = options.direction;
    start = helpers.getIdFromObject(start);
    end = helpers.getIdFromObject(end);
    <span class="keyword">if</span> ((start)&amp;&amp;(end)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>START martin=node(3), michael=node(7)
MATCH p = allShortestPaths(martin-[*]-michael)
RETURN p</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">var</span> type = (options.relationships.type) ? <span class="string">':'</span>+options.relationships.type : options.relationships.type;</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>this.cypher.start = {};</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">this</span>.cypher.start.a = <span class="string">'node('</span>+start+<span class="string">')'</span>;
      <span class="keyword">this</span>.cypher.start.b = <span class="string">'node('</span>+end+<span class="string">')'</span>;

      <span class="keyword">var</span> matchString = <span class="string">'p = '</span>+options.algorithm+<span class="string">'((a)-['</span>+type+( (options.max_depth&gt;<span class="number">0</span>) ? <span class="string">'..'</span>+options.max_depth : <span class="string">'*'</span> )+<span class="string">']-(b))'</span>;

      <span class="keyword">this</span>.cypher.match.push(matchString.replace(<span class="regexp">/\[\:\*+/</span>, <span class="string">'[*'</span>));
      <span class="keyword">this</span>.cypher.return_properties = [<span class="string">'p'</span>];
    }

    <span class="keyword">return</span> <span class="keyword">this</span>.exec(cb);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>Node.prototype.traversal = function(toNodeRelationshipPath, options, cb) { }</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Node.prototype.count = <span class="keyword">function</span>(identifier, cb) {
    <span class="keyword">this</span>.cypher._count = <span class="literal">true</span>;
    <span class="keyword">if</span> (<span class="keyword">typeof</span> identifier === <span class="string">'function'</span>) {
      cb = identifier;
      identifier = <span class="string">'*'</span>;
    }
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> identifier !== <span class="string">'string'</span>)
      identifier = <span class="string">'*'</span>;

    <span class="keyword">if</span> (Object.keys(<span class="keyword">this</span>.cypher.start).length &lt; <span class="number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>this.cypher.start = {};</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">this</span>.cypher.start[<span class="keyword">this</span>.__TYPE_IDENTIFIER__] = <span class="keyword">this</span>.__TYPE__+<span class="string">'(*)'</span>; <span class="comment">// all nodes by default</span>
    }
    <span class="keyword">this</span>.cypher.count = <span class="string">'COUNT('</span>+((<span class="keyword">this</span>.cypher._distinct) ? <span class="string">'DISTINCT '</span> : <span class="string">''</span>)+identifier+<span class="string">')'</span>;
    <span class="keyword">if</span> (<span class="keyword">this</span>.cypher._distinct)</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>set <code>this.cypher._distinct</code> to false</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">this</span>.distinct(<span class="literal">undefined</span>, <span class="literal">false</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>we only need the count column to return in this case</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (<span class="keyword">typeof</span> cb === <span class="string">'function'</span>)
      <span class="keyword">this</span>.exec(<span class="keyword">function</span>(err, result, debug){
        <span class="keyword">if</span> ((result)&amp;&amp;(result.data)) {
          <span class="keyword">if</span> (result.data.length === <span class="number">1</span>)
            result = result.data[<span class="number">0</span>][<span class="number">0</span>];
        }
        cb(err, result, debug);
      });
    <span class="keyword">this</span>._query_history_.push({ count: { distinct: <span class="keyword">this</span>.cypher._distinct, identifier: identifier } });
    <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// return self for chaining</span>
  }

  <span class="comment">/*
   * Query-Building methods
   */</span>

  Node.prototype._prepareQuery = <span class="keyword">function</span>() {
    <span class="keyword">var</span> query = _.extend(<span class="keyword">this</span>.cypher);
    <span class="keyword">var</span> label = (query.label) ? <span class="string">':'</span>+query.label : <span class="string">''</span>;

    <span class="keyword">if</span> ((<span class="keyword">this</span>.cypher.start) &amp;&amp; (Object.keys(<span class="keyword">this</span>.cypher.start).length &lt; <span class="number">1</span>)) {
      <span class="keyword">if</span> (query.from &gt; <span class="number">0</span>) {
        query.start = {};
        query.start.n = <span class="string">'node('</span>+query.from+<span class="string">')'</span>;
        query.return_properties.push(<span class="string">'n'</span>);
      }
      <span class="keyword">if</span> (query.to &gt; <span class="number">0</span>) {
        query.start.m = <span class="string">'node('</span>+query.to+<span class="string">')'</span>;
        query.return_properties.push(<span class="string">'m'</span>);
      }
    }

    <span class="keyword">var</span> relationships = <span class="string">''</span>;

    <span class="keyword">if</span> ((query.return_properties)&amp;&amp;(query.return_properties.constructor === Array))
      query.return_properties = _.uniq(query.return_properties).join(<span class="string">', '</span>)

    <span class="keyword">if</span> (query.relationship) {
      <span class="keyword">if</span> (query.relationship.constructor === Array) {
        relationships = <span class="string">':'</span>+helpers.escapeString(query.relationship.join(<span class="string">'|'</span>));
      } <span class="keyword">else</span> {
        relationships = <span class="string">':'</span>+helpers.escapeString(query.relationship);
      }
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>if COUNT(<em>) is set, no return properties are set
to avoid s.th. like `RETURN COUNT(</em>), n, r`</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    query.actionWith = (query.count) ? query.count : query.return_properties;</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>build in/outgoing directions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> ((query.incoming)||(query.outgoing)) {
      <span class="keyword">var</span> x = <span class="string">''</span>;
      <span class="keyword">var</span> y = <span class="string">''</span>;
      <span class="keyword">if</span> ((query.incoming)&amp;&amp;(query.outgoing))
        x = y = <span class="string">'-'</span>;
      <span class="keyword">else</span> {
        <span class="keyword">if</span> (query.incoming) {
          x = <span class="string">'&lt;-'</span>;
          y = <span class="string">'-'</span>;
        }
        <span class="keyword">if</span> (query.outgoing) {
          x = <span class="string">'-'</span>;
          y = <span class="string">'-&gt;'</span>;
        }
      }
      query.match.push(<span class="string">'(n'</span>+label+<span class="string">')'</span>+x+<span class="string">'[r'</span>+relationships+<span class="string">']'</span>+y+<span class="string">'('</span>+( (<span class="keyword">this</span>.cypher.to &gt; <span class="number">0</span>) ? <span class="string">'m'</span> : <span class="string">''</span> )+<span class="string">')'</span>);
    }

    <span class="keyword">var</span> __startObjectToString = <span class="keyword">function</span>(start) {
      <span class="keyword">var</span> s = [];
      <span class="keyword">for</span> (<span class="keyword">var</span> attribute <span class="keyword">in</span> start) {
        s.push(attribute+<span class="string">' = '</span>+start[attribute]);
      }
      <span class="keyword">return</span> s.join(<span class="string">', '</span>).trim();
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>guess return objects from start string if it&#39;s not set
e.g. START n = node(*), a = node(2) WHERE … RETURN (~&gt;) n, a;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> ((!query.return_properties)||((query.return_properties)&amp;&amp;(query.return_properties.length == <span class="number">0</span>)&amp;&amp;(<span class="keyword">this</span>.cypher.start)&amp;&amp;(Object.keys(<span class="keyword">this</span>.cypher.start).length &gt; <span class="number">0</span>))) {
      query.start_as_string = <span class="string">' '</span>+__startObjectToString(query.start)
      <span class="keyword">if</span> (<span class="regexp">/ [a-zA-Z]+ \= /</span>.test(query.start_as_string)) {
        <span class="keyword">var</span> matches = query.start_as_string;
        query.return_properties = [];
        matches = matches.match(<span class="regexp">/[\s\,]([a-z]+) \= /g</span>);
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; matches.length; i++) {
          query.return_properties.push(matches[i].replace(<span class="regexp">/^[\s\,]*([a-z]+).*$/i</span>,<span class="string">'$1'</span>));
        }
        <span class="keyword">if</span> ((Graph.request().version &gt;= <span class="number">2</span>)&amp;&amp;(query.return_properties.length === <span class="number">1</span>)&amp;&amp;(query.return_properties[<span class="number">0</span>] === <span class="string">'n'</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>try adding labels if we have only n[node] as return propert</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          query.return_properties.push(<span class="string">'labels(n)'</span>);
        }
        query.return_properties = query.return_properties.join(<span class="string">', '</span>);
      }
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>Set a fallback to START n = node(*) if it&#39;s not null</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> ((<span class="keyword">this</span>.cypher.start) &amp;&amp; (Object.keys(<span class="keyword">this</span>.cypher.start).length &lt; <span class="number">1</span>)&amp;&amp;(!(query.match.length &gt; <span class="number">0</span>))) {</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>query.start = &#39;n = node(*)&#39;;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      query.start[<span class="keyword">this</span>.__TYPE_IDENTIFIER__] = <span class="keyword">this</span>.__TYPE__+<span class="string">'(*)'</span>;
    }
    <span class="keyword">if</span> ((!(query.match.length&gt;<span class="number">0</span>))&amp;&amp;(<span class="keyword">this</span>.label)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p>e.g. ~&gt; MATCH (n:Person)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (<span class="keyword">this</span>.__TYPE_IDENTIFIER__ === <span class="string">'n'</span>)
        query.match.push(<span class="string">'(n:'</span>+<span class="keyword">this</span>.label+<span class="string">')'</span>);
      <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.__TYPE_IDENTIFIER__ === <span class="string">'r'</span>)
        query.match.push(<span class="string">'[r:'</span>+<span class="keyword">this</span>.label+<span class="string">']'</span>);
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>rule(s) for findById</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (query.by_id &gt; <span class="number">0</span>) {
      <span class="keyword">var</span> identifier = query.node_identifier || <span class="keyword">this</span>.__TYPE_IDENTIFIER__;</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>put in where clause if <code>START n = node(*)</code> or no START statement exists</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> ( (Object.keys(<span class="keyword">this</span>.cypher.start).length &lt; <span class="number">1</span>) || (<span class="keyword">this</span>.cypher.start.n === <span class="string">'node(*)'</span>) ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>we have to use the id method for the special key <code>id</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        query.where.push(<span class="string">"id("</span>+identifier+<span class="string">") = "</span>+query.by_id);
      }
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p>add all <code>HAS (property)</code> statements to where</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (query.hasProperty.length &gt; <span class="number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p>remove duplicate properties, not necessary but looks nicer</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">var</span> whereHasProperties = _.uniq(query.hasProperty);
      <span class="keyword">for</span> (<span class="keyword">var</span> i = whereHasProperties.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) {
        query.where.unshift(<span class="string">'HAS ('</span>+whereHasProperties[i]+<span class="string">')'</span>);
      }
    }

    query.start_as_string = __startObjectToString(query.start);

    <span class="keyword">return</span> query;
  }

  Node.prototype.toCypherQuery = <span class="keyword">function</span>() {
    <span class="keyword">var</span> query = <span class="keyword">this</span>._prepareQuery()
      , graph = Graph.start(query.start_as_string);

    <span class="keyword">if</span> (query.match.length &gt; <span class="number">0</span>)
      graph.match(query.match.join(<span class="string">' AND '</span>));
    <span class="keyword">if</span> ((query.where)&amp;&amp;(query.where.length &gt; <span class="number">0</span>))
      graph.where(query.where.join(<span class="string">' AND '</span>));
    <span class="keyword">if</span> (query.set)
      graph.set(query.set);

    <span class="keyword">if</span> (query.action)
      graph.custom(query.action+<span class="string">' '</span>+query.actionWith);
    <span class="keyword">else</span> <span class="keyword">if</span> (query._distinct)
      graph.returnDistinct(query.actionWith);
    <span class="keyword">else</span>
      graph.<span class="keyword">return</span>(query.actionWith);
    <span class="keyword">if</span> (query.order_by)
      graph.orderBy(query.order_by+<span class="string">' '</span>+query.order_direction);
    <span class="keyword">if</span> (query.skip)
      graph.skip(Number(query.skip));
    <span class="keyword">if</span> (query.limit)
      graph.limit(Number(query.limit));

    <span class="keyword">return</span> graph.toCypherQuery();
  }

  Node.prototype._start_node_id = <span class="keyword">function</span>(fallback) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> fallback === <span class="string">'undefined'</span>)
      fallback = <span class="string">'*'</span>
    <span class="keyword">if</span> (<span class="keyword">this</span>.cypher.from &gt; <span class="number">0</span>)
      <span class="keyword">return</span> <span class="keyword">this</span>.cypher.from;
    <span class="keyword">if</span> (<span class="keyword">this</span>.cypher.by_id)
      <span class="keyword">return</span> <span class="keyword">this</span>.cypher.by_id;
    <span class="keyword">else</span>
      <span class="keyword">return</span> (<span class="keyword">this</span>.hasId()) ? <span class="keyword">this</span>.id : fallback;
  }

  Node.prototype._end_node_id = <span class="keyword">function</span>(fallback) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> fallback === <span class="string">'undefined'</span>)
      fallback = <span class="string">'*'</span>
    <span class="keyword">return</span> (<span class="keyword">this</span>.cypher.to &gt; <span class="number">0</span>) ? <span class="keyword">this</span>.cypher.to : fallback;
  }

  Node.prototype.singletonForQuery = <span class="keyword">function</span>(cypher) {
    <span class="keyword">var</span> singleton = <span class="keyword">this</span>.singleton()
    singleton.cypher = _.extend(singleton.cypher, cypher);
    <span class="keyword">return</span> (<span class="keyword">this</span>.hasId()) ? singleton.findById(<span class="keyword">this</span>.id) : <span class="keyword">this</span>;
  }

  Node.prototype.exec = <span class="keyword">function</span>(cb, cypher_or_request) {
    <span class="keyword">var</span> request = <span class="literal">null</span>
      , cypherQuery = <span class="literal">null</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p>you can alternatively use an url</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (<span class="keyword">typeof</span> cypher_or_request === <span class="string">'string'</span>)
      cypherQuery = cypher_or_request;
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> cypher_or_request === <span class="string">'object'</span>)
      request = _.extend({ type: <span class="string">'get'</span>, data: {}, url: <span class="literal">null</span> }, cypher_or_request);

    <span class="keyword">if</span> (<span class="keyword">typeof</span> cb === <span class="string">'function'</span>) {
      <span class="keyword">var</span> cypher = <span class="keyword">this</span>.toCypherQuery();</pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <p>reset node, because it might be called from prototype
if we have only one return property, we resort this</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> ( (<span class="keyword">this</span>.cypher.return_properties)&amp;&amp;(<span class="keyword">this</span>.cypher.return_properties.length === <span class="number">1</span>) ) {
        <span class="keyword">if</span> (cypherQuery)
          <span class="keyword">this</span>.query(cypherQuery, cb);
        <span class="keyword">else</span> <span class="keyword">if</span> (request)
          <span class="keyword">this</span>.query(request, cb);
        <span class="keyword">else</span></pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p>default, use the build cypher query</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="keyword">this</span>.query(cypher, cb);
      } <span class="keyword">else</span> {
        <span class="keyword">this</span>.query(cypher, cb);
      }
    }
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  Node.prototype.query = <span class="keyword">function</span>(cypherQuery, options, cb) {
    <span class="keyword">var</span> self = <span class="keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <p>sort arguments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (<span class="keyword">typeof</span> options !== <span class="string">'object'</span>) {
      cb = options;
      options = {};
    }

    options.cypher = <span class="keyword">this</span>.cypher;

    <span class="keyword">var</span> graph = Graph.start();</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <p>apply option values from Node to request</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (<span class="keyword">this</span>.label)
      options.label = <span class="keyword">this</span>.label;

    options.recommendConstructor = <span class="keyword">this</span>.recommendConstructor();

    <span class="keyword">if</span> ((<span class="keyword">this</span>.cypher._useParameters) &amp;&amp; (<span class="keyword">this</span>.cypher.parameters) &amp;&amp; (Object.keys(<span class="keyword">this</span>.cypher.parameters).length &gt; <span class="number">0</span>)) {
      graph.parameters(<span class="keyword">this</span>.cypher.parameters);
    }

    <span class="keyword">if</span> (<span class="keyword">typeof</span> cypherQuery === <span class="string">'string'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p>check for stream flag
in stream case we use stream() instead of query()</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (<span class="keyword">this</span>._stream_) {
        <span class="keyword">return</span> graph.stream(cypherQuery, options, cb);
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> graph.query(cypherQuery, options, cb);
      }
    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> cypherQuery === <span class="string">'object'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <p>we expect a raw request object here
this is used to make get/post/put restful request
with the feature of process node data</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">var</span> request = cypherQuery;
      <span class="keyword">if</span> ( (!request.type) || (!request.data) || (!request.url) ) {
        <span class="keyword">return</span> cb(Error(<span class="string">"The 1st argument as request object must have the properties .url, .data and .type"</span>), <span class="literal">null</span>);
      }
      <span class="keyword">return</span> Graph.request()[request.type](request.url, request.data, <span class="keyword">function</span>(err, data, debug) {</pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p>transform to resultset</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        data = {
          data: [ [ data ] ]
        };
        graph._processResult(err, data, debug, self, cb);
      });
    } <span class="keyword">else</span> {
      <span class="keyword">return</span> cb(Error(<span class="string">"First argument must be a string with the cypher query"</span>), <span class="literal">null</span>);
    }
  }

  <span class="comment">/*
   * Relationship methods
   */</span>

  Node.prototype.withRelations = <span class="keyword">function</span>(relation, cb) {
    <span class="keyword">var</span> self = <span class="keyword">this</span>.singletonForQuery();
    self._query_history_.push({ withRelation: <span class="literal">true</span> });</pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <p>we expect a string or an array</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    self.cypher.relationship = (<span class="keyword">typeof</span> relation === <span class="string">'string'</span>) ? relation : relation.join(<span class="string">'|'</span>);
    self.cypher.incoming = <span class="literal">true</span>;
    self.cypher.outgoing = <span class="literal">true</span>;
    self.exec(cb);
    <span class="keyword">return</span> self;
  }

  Node.prototype.incomingRelations = <span class="keyword">function</span>(relation, cb) {
    <span class="keyword">var</span> self = <span class="keyword">this</span>.singletonForQuery();
    self._query_history_.push({ incomingRelationships: <span class="literal">true</span> }); <span class="comment">// only as a ”flag”</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span> relation !== <span class="string">'function'</span>) {
      self.cypher.relationship = relation;
    } <span class="keyword">else</span> {
      cb = relation;
    }
    self.cypher.node_identifier = <span class="string">'n'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p>self.cypher.start = {};</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    self.cypher.start.n = <span class="string">'node('</span>+self._start_node_id(<span class="string">'*'</span>)+<span class="string">')'</span>;
    <span class="keyword">if</span> (self.cypher.to &gt; <span class="number">0</span>)
      self.cypher.start.m = <span class="string">'node('</span>+self._end_node_id(<span class="string">'*'</span>)+<span class="string">')'</span>;
    self.cypher.incoming = <span class="literal">true</span>;
    self.cypher.outgoing = <span class="literal">false</span>;
    self.cypher.return_properties = [<span class="string">'r'</span>];
    self.exec(cb);
    <span class="keyword">return</span> self; <span class="comment">// return self for chaining</span>
  }

  Node.prototype.outgoingRelations = <span class="keyword">function</span>(relation, cb) {
    <span class="keyword">var</span> self = <span class="keyword">this</span>.singletonForQuery();
    self._query_history_.push({ outgoingRelationships: <span class="literal">true</span> }); <span class="comment">// only as a ”flag”</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span> relation !== <span class="string">'function'</span>) {
      self.cypher.relationship = relation;
    } <span class="keyword">else</span> {
      cb = relation;
    }
    self.cypher.node_identifier = <span class="string">'n'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <p>self.cypher.start = {};</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    self.cypher.start.n = <span class="string">'node('</span>+self._start_node_id(<span class="string">'*'</span>)+<span class="string">')'</span>;
    <span class="keyword">if</span> (self.cypher.to &gt; <span class="number">0</span>)
      self.cypher.start.m = <span class="string">'node('</span>+self._end_node_id(<span class="string">'*'</span>)+<span class="string">')'</span>;
    self.cypher.incoming = <span class="literal">false</span>;
    self.cypher.outgoing = <span class="literal">true</span>;
    self.cypher.return_properties = [<span class="string">'r'</span>];
    self.exec(cb);
    <span class="keyword">return</span> self; <span class="comment">// return self for chaining</span>
  }

  Node.prototype.incomingRelationsFrom = <span class="keyword">function</span>(node, relation, cb) {
    <span class="keyword">var</span> self = <span class="keyword">this</span>.singletonForQuery();
    self._query_history_.push({ incomingRelationshipsFrom: <span class="literal">true</span> }); <span class="comment">// only as a ”flag”</span>
    self.cypher.from = self.id || <span class="literal">null</span>;
    self.cypher.to = helpers.getIdFromObject(node);
    <span class="keyword">if</span> (<span class="keyword">typeof</span> relation !== <span class="string">'function'</span>)
      self.cypher.relationship = relation;
    self.cypher.return_properties = [<span class="string">'r'</span>];
    <span class="keyword">return</span> self.incomingRelations(relation, cb);
  }

  Node.prototype.outgoingRelationsTo = <span class="keyword">function</span>(node, relation, cb) {
    <span class="keyword">var</span> self = <span class="keyword">this</span>.singletonForQuery();
    self._query_history_.push({ outgoingRelationshipsTo: <span class="literal">true</span> }); <span class="comment">// only as a ”flag”</span>
    self.cypher.to = helpers.getIdFromObject(node);
    <span class="keyword">if</span> (<span class="keyword">typeof</span> relation !== <span class="string">'function'</span>)
      self.cypher.relationship = relation;
    self.cypher.return_properties = [<span class="string">'r'</span>];
    <span class="keyword">return</span> self.outgoingRelations(relation, cb);
  }

  Node.prototype.allDirections = <span class="keyword">function</span>(relation, cb) {
    <span class="keyword">var</span> self = <span class="keyword">this</span>.singletonForQuery();
    self._query_history_.push({ allDirections: <span class="literal">true</span> });
    <span class="keyword">if</span> (<span class="keyword">typeof</span> relation !== <span class="string">'function'</span>)
      self.cypher.relationship = relation;
    self.cypher.node_identifier = <span class="string">'n'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <p>self.cypher.start = {};</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    self.cypher.start.n = <span class="string">'node('</span>+self._start_node_id(<span class="string">'*'</span>)+<span class="string">')'</span>;
    self.cypher.start.m = <span class="string">'node('</span>+self._end_node_id(<span class="string">'*'</span>)+<span class="string">')'</span>;
    self.cypher.incoming = <span class="literal">true</span>;
    self.cypher.outgoing = <span class="literal">true</span>;
    self.cypher.return_properties = [<span class="string">'n'</span>, <span class="string">'m'</span>, <span class="string">'r'</span>];
    self.exec(cb);
    <span class="keyword">return</span> self; <span class="comment">// return self for chaining</span>
  }

  Node.prototype.relationsBetween = <span class="keyword">function</span>(node, relation, cb) {
    <span class="keyword">var</span> self = <span class="keyword">this</span>.singletonForQuery();
    self._query_history_.push({ relationshipsBetween: <span class="literal">true</span> });
    self.cypher.to = helpers.getIdFromObject(node);
    <span class="keyword">if</span> (<span class="keyword">typeof</span> relation !== <span class="string">'function'</span>)
      self.cypher.relationship = relation;
    self.cypher.return_properties = [<span class="string">'r'</span>];
    self.exec(cb);
    <span class="keyword">return</span> self.allDirections(relation, cb);
  }

  Node.prototype.allRelations = <span class="keyword">function</span>(relation, cb) {
    <span class="keyword">var</span> self = <span class="keyword">this</span>.singletonForQuery();
    <span class="keyword">var</span> label = (<span class="keyword">this</span>.cypher.label) ? <span class="string">':'</span>+<span class="keyword">this</span>.cypher.label : <span class="string">''</span>;
    <span class="keyword">if</span> (<span class="keyword">typeof</span> relation === <span class="string">'string'</span>) {
      relation = <span class="string">':'</span>+relation;
    } <span class="keyword">else</span> {
      cb = relation;
      relation = <span class="string">''</span>;
    }
    self._query_history_.push({ allRelationships: <span class="literal">true</span> });
    self.cypher.match.push(<span class="string">'(n)'</span>+label+<span class="string">'-[r'</span>+relation+<span class="string">']-()'</span>);
    self.cypher.return_properties = [<span class="string">'r'</span>];
    self.exec(cb);
    <span class="keyword">return</span> self; <span class="comment">// return self for chaining</span>
  }

  Node.prototype.limit = <span class="keyword">function</span>(limit, cb) {
    <span class="keyword">this</span>._query_history_.push({ LIMIT: limit });
    <span class="keyword">this</span>.cypher.limit = parseInt(limit);
    <span class="keyword">if</span> (limit === <span class="literal">NaN</span>)
      <span class="keyword">throw</span> Error(<span class="string">'LIMIT must be an integer number'</span>);
    <span class="keyword">if</span> (<span class="keyword">this</span>.cypher.action === <span class="string">'DELETE'</span>)
      <span class="keyword">throw</span> Error(<span class="string">"You can't use a limit on a DELETE, use WHERE instead to specify your limit"</span>);
    <span class="keyword">this</span>.exec(cb);
    <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// return self for chaining</span>
  }

  Node.prototype.skip = <span class="keyword">function</span>(skip, cb) {
    <span class="keyword">this</span>.cypher.skip = parseInt(skip);
    <span class="keyword">if</span> (skip === <span class="literal">NaN</span>)
      <span class="keyword">throw</span> Error(<span class="string">'SKIP must be an integer number'</span>);
    <span class="keyword">this</span>._query_history_.push({ SKIP: <span class="keyword">this</span>.cypher.skip });
    <span class="keyword">this</span>.exec(cb);
    <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// return self for chaining</span>
  }

  Node.prototype.distinct = <span class="keyword">function</span>(cb, value) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">'boolean'</span>)
      value = <span class="literal">true</span>;
    <span class="keyword">this</span>.cypher._distinct = value;
    <span class="keyword">this</span>._query_history_.push({ dictinct: value });
    <span class="keyword">this</span>.exec(cb);
    <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// return self for chaining</span>
  }

  Node.prototype.orderBy = <span class="keyword">function</span>(property, cb, identifier) {
    <span class="keyword">var</span> direction = <span class="string">''</span>;
    <span class="keyword">if</span> (<span class="keyword">typeof</span> property === <span class="string">'object'</span>) {
      <span class="keyword">var</span> key = Object.keys(property)[<span class="number">0</span>];
      cb = direction;
      direction = property[key];
      property = key;
      <span class="keyword">if</span> ( (<span class="keyword">typeof</span> direction === <span class="string">'string'</span>) &amp;&amp; ((<span class="regexp">/^(ASC|DESC)$/</span>).test(direction)) ) {
        <span class="keyword">this</span>.cypher.order_direction = direction;
      }
    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> property === <span class="string">'string'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <p>custom statement, no process at all
we use 1:1 the string</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">this</span>.cypher.order_by = property;
    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> cb === <span class="string">'string'</span>) {
      identifier = cb;
      cb = <span class="literal">null</span>;
    }
    <span class="keyword">if</span> (<span class="keyword">typeof</span> identifier === <span class="string">'undefined'</span>)
      identifier = <span class="keyword">this</span>.__TYPE_IDENTIFIER__;
    <span class="keyword">if</span> ((<span class="keyword">typeof</span> identifier === <span class="string">'string'</span>) &amp;&amp; (<span class="regexp">/^[nmr]$/i</span>.test(identifier))) {
      <span class="keyword">if</span> (identifier === <span class="string">'n'</span>) <span class="keyword">this</span>.whereNodeHasProperty(property);
      <span class="keyword">if</span> (identifier === <span class="string">'m'</span>) <span class="keyword">this</span>.whereEndNodeHasProperty(property);
      <span class="keyword">if</span> (identifier === <span class="string">'r'</span>) <span class="keyword">this</span>.whereRelationshipHasProperty(property);
    } <span class="keyword">else</span> {
      identifier = <span class="literal">null</span>;
    }

    <span class="keyword">if</span> (identifier) {</pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <p>s.th. like ORDER BY n.<code>name</code> ASC
escape property</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">this</span>.cypher.order_by = identifier + <span class="string">".`"</span>+property+<span class="string">"`"</span>;
    } <span class="keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <p>s.th. like ORDER BY n.name ASC</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">this</span>.cypher.order_by = property;
    }
    <span class="keyword">this</span>._query_history_.push({ ORDER_BY: <span class="keyword">this</span>.cypher.order_by });
    <span class="keyword">this</span>.exec(cb);
    <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// return self for chaining</span>
  }

  Node.prototype.orderNodeBy = <span class="keyword">function</span>(property, direction, cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.orderBy(property, direction, cb, <span class="string">'n'</span>);
  }

  Node.prototype.orderStartNodeBy = <span class="keyword">function</span>(property, direction, cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.orderNodeBy(property, direction, cb);
  }

  Node.prototype.orderEndNodeBy = <span class="keyword">function</span>(property, direction, cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.orderBy(property, direction, cb, <span class="string">'m'</span>);
  }

  Node.prototype.orderRelationshipBy = <span class="keyword">function</span>(property, direction, cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.orderBy(property, direction, cb, <span class="string">'r'</span>);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <h3>Adds a string to the MATCH statement</h3>
<p>e.g.: &#39;p:PERSON-[:KNOWS|:FOLLOWS]-&gt;a:Actor-[:ACTS]-&gt;m&#39;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Node.prototype.match = <span class="keyword">function</span>(string, cb) {</pre></div></div>
            
        </li>
        
        
        <li id="section-96">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <p>we guess that we match a node if we have s.th. like <code>n(:Person)</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (<span class="regexp">/^n(\:[a-zA-Z]+)*$/</span>.test(string))
      string = <span class="string">'('</span>+string+<span class="string">')'</span>;
    <span class="keyword">this</span>._query_history_.push({ MATCH: string });
    <span class="keyword">this</span>.cypher.match.push(string);
    <span class="keyword">this</span>.exec(cb);
    <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// return self for chaining</span>
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-97">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <h3>Adds s.th. to the RETURN statement</h3>
<p>Can be a string or an array
e.g. as string:  &#39;award.name AS Award, awardee.name AS WonBy&#39;
e.g. as array: [ &#39;award.name AS Award&#39;, &#39;awardee.name AS WonBy&#39; ]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Node.prototype.<span class="keyword">return</span> = <span class="keyword">function</span>(returnStatement, cb, options) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">'undefined'</span>)
      options = { add: <span class="literal">false</span> };
    <span class="keyword">if</span> (!options.add)
      <span class="keyword">this</span>.cypher.return_properties = [];
    <span class="keyword">if</span> (returnStatement) {
      <span class="keyword">this</span>.cypher.return_properties = <span class="keyword">this</span>.cypher.return_properties.concat(
        (returnStatement.constructor === Array) ? returnStatement : returnStatement.split(<span class="string">', '</span>)
      );
      <span class="keyword">this</span>._query_history_.push({ RETURN: <span class="keyword">this</span>.cypher.return_properties });
    }
    <span class="keyword">this</span>.exec(cb);
    <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// return self for chaining</span>
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-98">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>
              <h3>Sets or resets the START statement</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Node.prototype.start = <span class="keyword">function</span>(start, cb) {
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="keyword">if</span> (!self._is_singleton_)
      self = <span class="keyword">this</span>.singleton(<span class="literal">undefined</span>, <span class="keyword">this</span>);
    <span class="keyword">if</span> (self.label) self.withLabel(self.label);</pre></div></div>
            
        </li>
        
        
        <li id="section-99">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-99">&#182;</a>
              </div>
              <p>self.resetQuery();</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (<span class="keyword">typeof</span> start !== <span class="string">'string'</span>)
      self.cypher.start = <span class="literal">null</span>;
    <span class="keyword">else</span>
      self.cypher.start = start;
    self._query_history_.push({ START: self.cypher.start });
    self.exec(cb);
    <span class="keyword">return</span> self; <span class="comment">// return self for chaining</span>
  }

  Node.prototype.where = <span class="keyword">function</span>(where, cb, options) {
    <span class="keyword">this</span>.cypher.where = [];
    <span class="keyword">if</span> (_.isObject(where)) {
      <span class="keyword">if</span> (Object.keys(where).length === <span class="number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-100">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-100">&#182;</a>
              </div>
              <p>return here</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">this</span>.exec(cb);
        <span class="keyword">return</span> <span class="keyword">this</span>;
      }
      <span class="keyword">if</span> (!_.isArray(where))
        where = [ where ];
    }

    <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">'undefined'</span>)
      options = {};
    <span class="keyword">if</span> (<span class="keyword">typeof</span> options.identifier !== <span class="string">'string'</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-101">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-101">&#182;</a>
              </div>
              <p>good or bad idea that we use by default n as identifier?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      options.identifier = <span class="string">'n'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-102">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-102">&#182;</a>
              </div>
              <p>add identifier to return properties if not exists already</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (_.indexOf(<span class="keyword">this</span>.cypher.return_properties, options.identifier) === -<span class="number">1</span>)
      <span class="keyword">this</span>.cypher.return_properties.push(options.identifier);


    <span class="keyword">if</span> (<span class="keyword">this</span>.cypher.start) {
      <span class="keyword">if</span> (!<span class="keyword">this</span>.cypher.start.n)
        <span class="keyword">this</span>.cypher.start.n = <span class="string">'node(*)'</span>;
      <span class="keyword">if</span> (<span class="keyword">this</span>.cypher.start.m)
        <span class="keyword">this</span>.cypher.start.m = <span class="string">'node(*)'</span>;
      <span class="keyword">if</span> (options.identifier === <span class="string">'r'</span>)
        <span class="keyword">this</span>.cypher.start.r = <span class="string">'relationship(*)'</span>;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-103">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-103">&#182;</a>
              </div>
              <p>use parameters for query or send an ordinary string?
<a href="http://docs.neo4j.org/chunked/stable/rest-api-cypher.html">http://docs.neo4j.org/chunked/stable/rest-api-cypher.html</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (<span class="keyword">typeof</span> options.valuesToParameters === <span class="string">'undefined'</span>)
      options.valuesToParameters = Boolean(<span class="keyword">this</span>.cypher._useParameters);</pre></div></div>
            
        </li>
        
        
        <li id="section-104">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-104">&#182;</a>
              </div>
              <p>if already parameters are added, starting with {<em>value#i</em>} instead of {<em>value0</em>}</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> ((<span class="keyword">this</span>.cypher.parameters)&amp;&amp;(<span class="keyword">this</span>.cypher.parameters.length &gt; <span class="number">0</span>))
      options.parametersStartCountAt = <span class="keyword">this</span>.cypher.parameters.length;
    <span class="keyword">var</span> condition = <span class="keyword">new</span> helpers.ConditionalParameters(_.extend(where), options)
      , whereCondition = condition.toString();
    <span class="keyword">this</span>.cypher.where.push(whereCondition);
    <span class="keyword">if</span> ((options.valuesToParameters) &amp;&amp; (condition.parameters))
      <span class="keyword">this</span>._addParametersToCypher(condition.parameters);

    <span class="keyword">this</span>._query_history_.push({ WHERE: whereCondition });

    <span class="keyword">this</span>.exec(cb);
    <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// return self for chaining</span>
  }

  Node.prototype.whereStartNode = <span class="keyword">function</span>(where, cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.where(where, cb, { identifier: <span class="string">'n'</span> });
  }

  Node.prototype.whereEndNode = <span class="keyword">function</span>(where, cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.where(where, cb, { identifier: <span class="string">'m'</span> });
  }

  Node.prototype.whereNode = <span class="keyword">function</span>(where, cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.where(where, cb, { identifier: <span class="string">'n'</span> });
  }

  Node.prototype.whereRelationship = <span class="keyword">function</span>(where, cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.where(where, cb, { identifier: <span class="string">'r'</span> });
  }

  Node.prototype.whereRelation = <span class="keyword">function</span>(where, cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.whereRelationship(where, cb);
  }

  Node.prototype.whereHasProperty = <span class="keyword">function</span>(property, identifier, cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.andHasProperty(property, identifier, cb);
  }

  Node.prototype.andHasProperty = <span class="keyword">function</span>(property, identifier, cb) {
    <span class="keyword">if</span> (_.isFunction(identifier)) {
      cb = identifier;
      identifier = <span class="literal">null</span>;
    }
    <span class="keyword">if</span> (<span class="keyword">typeof</span> property !== <span class="string">'string'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-105">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-105">&#182;</a>
              </div>
              <p>we need a property to proceed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">return</span> cb(Error(<span class="string">'Property name is mandatory.'</span>),<span class="literal">null</span>);
    }
    <span class="keyword">if</span> (<span class="regexp">/^[nmr]\./</span>.test(property))</pre></div></div>
            
        </li>
        
        
        <li id="section-106">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-106">&#182;</a>
              </div>
              <p>remove identifier</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      property = property.replace(<span class="regexp">/^[nmr]\./</span>,<span class="string">''</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-107">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-107">&#182;</a>
              </div>
              <p>if NOT default to true/false, no property condition is needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (!<span class="regexp">/[\!\?]$/</span>.test(property)) {
      <span class="keyword">if</span> (<span class="keyword">this</span>.cypher.return_properties.length === <span class="number">0</span>) {
        <span class="keyword">this</span>.findAll();
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-108">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-108">&#182;</a>
              </div>
              <p>no identifier found, guessing from return properties</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (<span class="keyword">typeof</span> identifier !== <span class="string">'string'</span>)
        identifier = <span class="keyword">this</span>.cypher.return_properties[<span class="keyword">this</span>.cypher.return_properties.length-<span class="number">1</span>];
      <span class="keyword">this</span>.cypher.hasProperty.push(identifier+<span class="string">'.`'</span>+property+<span class="string">'`'</span>);
      <span class="keyword">this</span>._query_history_.push({ HAS: { identifier: identifier, property: property }});
    }
    <span class="keyword">this</span>.exec(cb);
    <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// return self for chaining</span>
  }

  Node.prototype.whereNodeHasProperty = <span class="keyword">function</span>(property, cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.andHasProperty(property, <span class="string">'n'</span>, cb);
  }

  Node.prototype.whereStartNodeHasProperty = <span class="keyword">function</span>(property, cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.andHasProperty(property, <span class="string">'n'</span>, cb);
  }

  Node.prototype.whereEndNodeHasProperty = <span class="keyword">function</span>(property, cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.andHasProperty(property, <span class="string">'m'</span>, cb);
  }

  Node.prototype.whereRelationshipHasProperty = <span class="keyword">function</span>(property, cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.andHasProperty(property, <span class="string">'r'</span>, cb);
  }

  Node.prototype.<span class="keyword">delete</span> = <span class="keyword">function</span>(cb) {
    <span class="keyword">if</span> (<span class="keyword">this</span>.hasId())
      <span class="keyword">return</span> cb(Error(<span class="string">'To delete a node, use remove(). delete() is for queries'</span>),<span class="literal">null</span>);
    <span class="keyword">this</span>._query_history_.push({ DELETE: <span class="literal">true</span> });
    <span class="keyword">this</span>.cypher.action = <span class="string">'DELETE'</span>;
    <span class="keyword">if</span> (<span class="keyword">this</span>.cypher.limit)
      <span class="keyword">throw</span> Error(<span class="string">"You can't use a limit on a DELETE, use WHERE instead to specify your limit"</span>);
    <span class="keyword">return</span> <span class="keyword">this</span>.exec(cb);
  }

  Node.prototype.deleteIncludingRelations = <span class="keyword">function</span>(cb) {
    <span class="keyword">var</span> label = (<span class="keyword">this</span>.label) ? <span class="string">":"</span>+<span class="keyword">this</span>.label : <span class="string">""</span>;
    <span class="keyword">if</span> (Object.keys(<span class="keyword">this</span>.cypher.start).length &lt; <span class="number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-109">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-109">&#182;</a>
              </div>
              <p>this.cypher.start = {};</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">this</span>.cypher.start[<span class="keyword">this</span>.__TYPE_IDENTIFIER__] = <span class="keyword">this</span>.__TYPE__+<span class="string">"(*)"</span>;
    }
    <span class="keyword">this</span>.cypher.match.push([ <span class="string">'('</span>+<span class="keyword">this</span>.__TYPE_IDENTIFIER__+label+<span class="string">")-[r?]-()"</span> ]);
    <span class="keyword">this</span>.cypher.return_properties = [ <span class="string">"n"</span>, <span class="string">"r"</span> ];
    <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">delete</span>(cb);
  }

  Node.prototype.remove = <span class="keyword">function</span>(cb) {
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="keyword">this</span>.onBeforeRemove(<span class="keyword">function</span>(<span class="comment">/*err*/</span>) {
      <span class="keyword">if</span> (self._is_singleton_)
        <span class="keyword">return</span> cb(Error(<span class="string">"To delete results of a query use delete(). remove() is for removing an instanced "</span>+<span class="keyword">this</span>.__TYPE__),<span class="literal">null</span>);
      <span class="keyword">if</span> (self.hasId()) {
        <span class="keyword">return</span> Graph.request().<span class="keyword">delete</span>(self.__TYPE__+<span class="string">'/'</span>+self.id, cb);
      }
    })
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  Node.prototype.onBeforeRemove = <span class="keyword">function</span>(next) { next(<span class="literal">null</span>,<span class="literal">null</span>); }</pre></div></div>
            
        </li>
        
        
        <li id="section-110">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-110">&#182;</a>
              </div>
              <p>was mistakenly called <code>removeWithRelationships</code>, so it is renamed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Node.prototype.removeIncludingRelations = <span class="keyword">function</span>(cb) {
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="keyword">return</span> <span class="keyword">this</span>.removeAllRelations(<span class="keyword">function</span>(err) {
      <span class="keyword">if</span> (err)
        <span class="keyword">return</span> cb(err, <span class="literal">null</span>);
      <span class="keyword">else</span> <span class="comment">// remove now node</span>
        <span class="keyword">return</span> self.remove(cb);
    });
  }

  Node.prototype.removeOutgoingRelations = <span class="keyword">function</span>(type, cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.removeRelations(type, cb, { direction: <span class="string">'-&gt;'</span> });
  }
  Node.prototype.removeIncomingRelations = <span class="keyword">function</span>(type, cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.removeRelations(type, cb, { direction: <span class="string">'&lt;-'</span> });
  }

  Node.prototype.removeAllRelations = <span class="keyword">function</span>(cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.removeRelations(<span class="string">''</span>, cb);
  }

  Node.prototype.removeRelations = <span class="keyword">function</span>(type, cb, _options) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> type === <span class="string">'function'</span>) {
      _options = cb;
      cb = type;
      type = <span class="literal">null</span>;
    }
    <span class="keyword">var</span> defaultOptions = {
      direction: <span class="string">'all'</span>, <span class="comment">// incoming / outgoing</span>
      type: type,
      endNodeId: <span class="literal">null</span>
    };
    <span class="keyword">if</span> (<span class="keyword">typeof</span> _options === <span class="string">'undefined'</span>) {
      _options = _.extend({},defaultOptions);
    } <span class="keyword">else</span> {
      _options = _.extend({},defaultOptions,_options);
    }
    <span class="keyword">if</span> ((<span class="keyword">this</span>.hasId())&amp;&amp;(<span class="keyword">typeof</span> cb === <span class="string">'function'</span>)) {
      <span class="keyword">var</span> direction = _options.direction;
      <span class="keyword">if</span> ( (!(direction === <span class="string">'incoming'</span>)) || (!(direction === <span class="string">'outgoing'</span>)) )
        direction = <span class="string">'all'</span>;
      Node.prototype.findById(<span class="keyword">this</span>.id)[direction+<span class="string">'Relations'</span>]().<span class="keyword">delete</span>(cb);
    } <span class="keyword">else</span> {
      cb(Error(<span class="string">"You can remove relationships only from an instanced node /w a valid cb"</span>), <span class="literal">null</span>);
    }
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  Node.prototype.createRelation = <span class="keyword">function</span>(options, cb) {
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    options = _.extend({
      from_id: <span class="keyword">this</span>.id,
      to_id: <span class="literal">null</span>,
      type: <span class="literal">null</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-111">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-111">&#182;</a>
              </div>
              <p>unique: false ,// TODO: implement!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      properties: <span class="literal">null</span>,
      distinct: <span class="literal">null</span>
    }, options);
    <span class="keyword">if</span> (<span class="keyword">typeof</span> options.type !== <span class="string">'string'</span>)
      <span class="keyword">throw</span> Error(<span class="string">"You have to give the type of relationship, e.g. 'knows|follows'"</span>);
    <span class="keyword">if</span> (options.properties)
      options.properties = helpers.flattenObject(options.properties);


    <span class="keyword">if</span> ((_.isNumber(options.from_id))&amp;&amp;(_.isNumber(options.to_id))&amp;&amp;(<span class="keyword">typeof</span> cb === <span class="string">'function'</span>)) {
      <span class="keyword">if</span> (options.distinct) {
        Node.findById(options.from_id).outgoingRelationsTo(options.to_id, options.type, <span class="keyword">function</span>(err, result) {
          <span class="keyword">if</span> (err)
            <span class="keyword">return</span> cb(err, result);
          <span class="keyword">if</span> ((result) &amp;&amp; (result.length === <span class="number">1</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-112">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-112">&#182;</a>
              </div>
              <p>if we have only one relationship, we update this one</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            neo4jrestful.constructorOf(<span class="string">'Relationship'</span>).findById(result[<span class="number">0</span>].id, <span class="keyword">function</span>(err, relationship){
              <span class="keyword">if</span> (relationship) {
                <span class="keyword">if</span> (options.properties)
                  relationship.data = options.properties;
                <span class="keyword">if</span> (options.type)
                  relationship.type = options.type;
                relationship.save(cb);
              } <span class="keyword">else</span> {
                cb(err, relationship);
              }
            })
          } <span class="keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-113">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-113">&#182;</a>
              </div>
              <p>we create a new one</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            neo4jrestful.constructorOf(<span class="string">'Relationship'</span>).create(options.type, options.properties, options.from_id, options.to_id, cb);
            <span class="keyword">return</span> self;
          }
        });
      } <span class="keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-114">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-114">&#182;</a>
              </div>
              <p>create relationship</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        neo4jrestful.constructorOf(<span class="string">'Relationship'</span>).create(options.type, options.properties, options.from_id, options.to_id, cb);
        <span class="keyword">return</span> self;
      }
    } <span class="keyword">else</span> {
      cb(Error(<span class="string">'Missing from_id('</span>+options.from_id+<span class="string">') or to_id('</span>+options.to_id+<span class="string">') OR no cb attached'</span>), <span class="literal">null</span>);
    }
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  Node.prototype.createRelationBetween = <span class="keyword">function</span>(node, type, properties, cb, options) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> options !== <span class="string">'object'</span>) options = {};
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="keyword">if</span> (<span class="keyword">typeof</span> properties === <span class="string">'function'</span>) {
      cb = properties;
      properties = {};
    }
    <span class="keyword">if</span> ((<span class="keyword">this</span>.hasId())&amp;&amp;(helpers.getIdFromObject(node))) {</pre></div></div>
            
        </li>
        
        
        <li id="section-115">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-115">&#182;</a>
              </div>
              <p>to avoid deadlocks
we have to create the relationships sequentially</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      self.createRelationTo(node, type, properties, <span class="keyword">function</span>(err, resultFirst, debug_a){
        self.createRelationFrom(node, type, properties, <span class="keyword">function</span>(secondErr, resultSecond, debug_b) {
          <span class="keyword">if</span> ((err)||(secondErr)) {
            <span class="keyword">if</span> ((err)&amp;&amp;(secondErr))
              cb([err, secondErr], <span class="literal">null</span>, [ debug_a, debug_b ]);
            <span class="keyword">else</span>
              cb(err || secondErr, <span class="literal">null</span>, [ debug_a, debug_b ]);
          } <span class="keyword">else</span> {
            cb(<span class="literal">null</span>, [ resultFirst, resultSecond ], debug_a || debug_b);
          }
        }, options);
      }, options);
    } <span class="keyword">else</span> {
      cb(Error(<span class="string">"You need two instanced nodes as start and end point"</span>), <span class="literal">null</span>);
    }
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  Node.prototype.createRelationTo = <span class="keyword">function</span>(node, type, properties, cb, options) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> options !== <span class="string">'object'</span>) options = {};
    <span class="keyword">var</span> args;
    <span class="keyword">var</span> id = helpers.getIdFromObject(node);
    ( ( args = helpers.sortOptionsAndCallbackArguments(properties, cb) ) &amp;&amp; ( properties = args.options ) &amp;&amp; ( cb = args.callback ) );
    options = _.extend({
      properties: properties,
      to_id: id,
      type: type
    }, options);
    <span class="keyword">return</span> <span class="keyword">this</span>.createRelation(options, cb);
  }

  Node.prototype.createRelationFrom = <span class="keyword">function</span>(node, type, properties, cb, options) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> options !== <span class="string">'object'</span>) options = {};
    <span class="keyword">var</span> args;
    <span class="keyword">var</span> id = helpers.getIdFromObject(node);
    ( ( args = helpers.sortOptionsAndCallbackArguments(properties, cb) ) &amp;&amp; ( properties = args.options ) &amp;&amp; ( cb = args.callback ) );
    options = _.extend({
      properties: properties,
      from_id: id,
      to_id: <span class="keyword">this</span>.id,
      type: type
    }, options);
    <span class="keyword">return</span> <span class="keyword">this</span>.createRelation(options, cb);
  }

  Node.prototype.createOrUpdateRelation = <span class="keyword">function</span>(options, cb) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> options !== <span class="string">'object'</span>) options = {};
    options.distinct = <span class="literal">true</span>;
    <span class="keyword">return</span> <span class="keyword">this</span>.createRelation(options, cb);
  }

  Node.prototype.createOrUpdateRelationTo = <span class="keyword">function</span>(node, type, properties, cb, options) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> options !== <span class="string">'object'</span>) options = {};
    options.distinct = <span class="literal">true</span>;
    <span class="keyword">return</span> <span class="keyword">this</span>.createRelationTo(node, type, properties, cb, options);
  }

  Node.prototype.createOrUpdateRelationFrom = <span class="keyword">function</span>(node, type, properties, cb, options) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> options !== <span class="string">'object'</span>) options = {};
    options.distinct = <span class="literal">true</span>;
    <span class="keyword">return</span> <span class="keyword">this</span>.createRelationFrom(node, type, properties, cb, options);
  }

  Node.prototype.createOrUpdateRelationBetween = <span class="keyword">function</span>(node, type, properties, cb, options) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> options !== <span class="string">'object'</span>) options = {};
    options.distinct = <span class="literal">true</span>;
    <span class="keyword">return</span> <span class="keyword">this</span>.createRelationBetween(node, type, properties, cb, options);
  }

  Node.prototype.recommendConstructor = <span class="keyword">function</span>(Fallback) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> Fallback !== <span class="string">'function'</span>)
      Fallback = <span class="keyword">this</span>.constructor;
    <span class="keyword">var</span> label = (<span class="keyword">this</span>.label) ? <span class="keyword">this</span>.label : ( ((<span class="keyword">this</span>.labels)&amp;&amp;(<span class="keyword">this</span>.labels.length===<span class="number">1</span>)) ? <span class="keyword">this</span>.labels[<span class="number">0</span>] : <span class="literal">null</span> );
    <span class="keyword">return</span> (label) ? Node.registered_model(label) || Fallback : Fallback;
  }

  <span class="comment">/*
   * Label methods
   */</span>

  Node.prototype.requestLabels = <span class="keyword">function</span>(cb) {
    <span class="keyword">if</span> ((<span class="keyword">this</span>.hasId())&amp;&amp;(<span class="keyword">typeof</span> cb === <span class="string">'function'</span>)) {
      Graph.request().get(<span class="string">'node/'</span>+<span class="keyword">this</span>.id+<span class="string">'/labels'</span>, cb);
    }
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  Node.prototype.setLabel = <span class="keyword">function</span>(label) {
    <span class="keyword">return</span> <span class="keyword">this</span>.setLabels([ label ]);
  }

  Node.prototype.setLabels = <span class="keyword">function</span>(labels) {
    <span class="keyword">if</span> (_.isArray(labels)) {
      <span class="keyword">this</span>.labels = labels;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-116">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-116">&#182;</a>
              </div>
              <p>if we have only one label we set this to default label</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> ((_.isArray(<span class="keyword">this</span>.labels))&amp;&amp;(<span class="keyword">this</span>.labels.length === <span class="number">1</span>)) {
      <span class="keyword">this</span>.label = <span class="keyword">this</span>.labels[<span class="number">0</span>];
    }
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  Node.prototype.labelsAsArray = <span class="keyword">function</span>() {
    <span class="keyword">var</span> labels = <span class="keyword">this</span>.labels;
    <span class="keyword">if</span> (!_.isArray(labels))
      labels = [];
    <span class="keyword">if</span> (<span class="keyword">this</span>.label)
      labels.push(<span class="keyword">this</span>.label);
    labels = _.uniq(labels);
    <span class="keyword">return</span> labels;
  }

  Node.prototype.allLabels = <span class="keyword">function</span>(cb) {
    <span class="keyword">if</span> ( (<span class="keyword">this</span>.hasId()) &amp;&amp; (_.isFunction(cb)) ) {
      <span class="keyword">return</span> Graph.request().get(<span class="string">'node/'</span>+<span class="keyword">this</span>.id+<span class="string">'/labels'</span>, cb);
    }
  }

  Node.prototype.createLabel = <span class="keyword">function</span>(label, cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.createLabels([ label ], cb);
  }

  Node.prototype.createLabels = <span class="keyword">function</span>(labels, cb) {
    <span class="keyword">if</span> ( (<span class="keyword">this</span>.hasId()) &amp;&amp; (_.isFunction(cb)) )
      <span class="keyword">return</span> Graph.request().post(<span class="string">'node/'</span>+<span class="keyword">this</span>.id+<span class="string">'/labels'</span>, { data: labels }, cb);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-117">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-117">&#182;</a>
              </div>
              <p><a href="http://docs.neo4j.org/chunked/milestone/rest-api-node-labels.html">http://docs.neo4j.org/chunked/milestone/rest-api-node-labels.html</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Node.prototype.addLabels = <span class="keyword">function</span>(labels, cb) {
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="keyword">if</span> ( (<span class="keyword">this</span>.hasId()) &amp;&amp; (_.isFunction(cb)) ) {
      <span class="keyword">if</span> (!_.isArray(labels))
        labels = [ labels ];
      self.allLabels(<span class="keyword">function</span>(err, storedLabels, debug) {
        <span class="keyword">if</span> (err)
          <span class="keyword">return</span> cb(err, storedLabels, debug);
        <span class="keyword">if</span> (!_.isArray(storedLabels))
          storedLabels = [];
        <span class="keyword">var</span> addLabels = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-118">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-118">&#182;</a>
              </div>
              <p>only add new labels</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        labels.forEach(<span class="keyword">function</span>(label){
          <span class="keyword">if</span> (_.indexOf(storedLabels, label) === -<span class="number">1</span>)
            addLabels.push(label);
        });
        <span class="keyword">if</span> (addLabels.length &gt; <span class="number">0</span>)
          self.createLabels(addLabels, cb);
        <span class="keyword">else</span>
          cb(<span class="literal">null</span>, storedLabels, debug);
      });
    } <span class="keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-119">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-119">&#182;</a>
              </div>
              <p>otherwise it can be used as a setter</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">this</span>.labels = labels;
      <span class="keyword">if</span> (labels.length===<span class="number">1</span>)
        <span class="keyword">this</span>.label = labels[<span class="number">0</span>];
    }
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  Node.prototype.addLabel = <span class="keyword">function</span>(label, cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.addLabels([ label ], cb);
  }

  Node.prototype.replaceLabels = <span class="keyword">function</span>(labels, cb) {
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="keyword">if</span> ( (<span class="keyword">this</span>.hasId()) &amp;&amp; (_.isFunction(cb)) ) {
      <span class="keyword">if</span> (!_.isArray(labels))
        labels = [ labels ];
      self.labels = labels;</pre></div></div>
            
        </li>
        
        
        <li id="section-120">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-120">&#182;</a>
              </div>
              <p>remove all labels</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      self.removeLabels(<span class="keyword">function</span>(err, res, debug) {
        <span class="keyword">if</span> (err)
          <span class="keyword">return</span> cb(err, res, debug);</pre></div></div>
            
        </li>
        
        
        <li id="section-121">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-121">&#182;</a>
              </div>
              <p>an add all labels</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">return</span> self.addLabels(labels, cb);
      })</pre></div></div>
            
        </li>
        
        
        <li id="section-122">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-122">&#182;</a>
              </div>
              <p>This doesn&#39;t work anymore since v2 M6 …
<a href="https://github.com/neo4j/neo4j/issues/1279">https://github.com/neo4j/neo4j/issues/1279</a>
Graph.request().put(&#39;node/&#39;+self.id+&#39;/labels&#39;, { data: labels }, cb);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    }
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  Node.prototype.removeLabels = <span class="keyword">function</span>(cb) {
    <span class="keyword">var</span> id = <span class="keyword">this</span>.id;
    <span class="keyword">if</span> ( (<span class="keyword">this</span>.hasId()) &amp;&amp; (_.isFunction(cb)) ) {
      <span class="keyword">this</span>.allLabels(<span class="keyword">function</span>(err, labels, debug) {
        <span class="keyword">if</span> ((err)||(!labels))
          <span class="keyword">return</span> cb(err, labels, debug);
        <span class="keyword">var</span> todo = labels.length;
        <span class="keyword">if</span> (todo === <span class="number">0</span>)
          <span class="keyword">return</span> cb(<span class="literal">null</span>, <span class="literal">null</span>, debug);
        labels.forEach(<span class="keyword">function</span>(label) {
          <span class="keyword">return</span> Graph.request().<span class="keyword">delete</span>(<span class="string">'node/'</span>+id+<span class="string">'/labels/'</span>+label, <span class="keyword">function</span>() {
            todo--;
            <span class="keyword">if</span> (todo === <span class="number">0</span>)
              cb(<span class="literal">null</span>, <span class="literal">null</span>, debug);
          });
        });
      })

    } <span class="keyword">else</span> {
      <span class="keyword">return</span> <span class="keyword">this</span>;
    }
  }

  Node.prototype.toObject = <span class="keyword">function</span>() {
    <span class="keyword">return</span> {
      id: <span class="keyword">this</span>.id,
      classification: <span class="keyword">this</span>.classification,
      data: _.clone(<span class="keyword">this</span>.data),
      uri: <span class="keyword">this</span>.uri,
      label: (<span class="keyword">this</span>.label) ? <span class="keyword">this</span>.label : <span class="literal">null</span>,
      labels: (<span class="keyword">this</span>.labels.length &gt; <span class="number">0</span>) ? _.clone(<span class="keyword">this</span>.labels) : []
    };
  }

  <span class="comment">/*
   * Request methods
   */</span>

  Node.prototype.stream = <span class="keyword">function</span>(cb) {
    <span class="keyword">this</span>._stream_ = <span class="literal">true</span>;
    <span class="keyword">return</span> <span class="keyword">this</span>.exec(cb);
  }

  Node.prototype.each = <span class="keyword">function</span>(cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.stream(cb);
  }

  <span class="comment">/*
   * STATIC METHODS for `find` Queries
   */</span>

  Node.prototype.find = <span class="keyword">function</span>(where, cb) {
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="keyword">if</span> (!self._is_singleton_)
      self = <span class="keyword">this</span>.singleton(<span class="literal">undefined</span>, <span class="keyword">this</span>);
    self._query_history_.push({ find: <span class="literal">true</span> });
    <span class="keyword">if</span> (self.label) self.withLabel(self.label);
    <span class="keyword">if</span> ((<span class="keyword">typeof</span> where === <span class="string">'string'</span>)||(<span class="keyword">typeof</span> where === <span class="string">'object'</span>)) {
      <span class="keyword">return</span> self.where(where,cb);
    } <span class="keyword">else</span> {
      <span class="keyword">return</span> self.findAll(cb);
    }
  }

  Node.prototype.findOne = <span class="keyword">function</span>(where, cb) {
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="keyword">if</span> (<span class="keyword">typeof</span> where === <span class="string">'function'</span>) {
      cb = where;
      where = <span class="literal">undefined</span>;
    }
    self = <span class="keyword">this</span>.find(where);
    self.cypher.limit = <span class="number">1</span>;
    <span class="keyword">return</span> self.exec(cb);
  }

  Node.prototype.findById = <span class="keyword">function</span>(id, cb) {
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="keyword">if</span> (!self._is_singleton_)
      self = <span class="keyword">this</span>.singleton(<span class="literal">undefined</span>, <span class="keyword">this</span>);
    <span class="keyword">var</span> id = Number(id);
    <span class="keyword">if</span> (!id)
      <span class="keyword">throw</span> Error(<span class="string">'You have to give a number like argument as id'</span>);
    self._query_history_.push({ findById: id });
    <span class="keyword">if</span> ( (_.isNumber(Number(id))) &amp;&amp; (<span class="keyword">typeof</span> cb === <span class="string">'function'</span>) ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-123">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-123">&#182;</a>
              </div>
              <p>to reduce calls we&#39;ll make a specific restful request for one node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      Graph
        .disableLoading()
        .start(<span class="string">'n = node('</span>+id+<span class="string">')'</span>)
        .<span class="keyword">return</span>(<span class="string">'n as node, labels(n) AS labels'</span>)
        .exec(<span class="keyword">function</span>(err, result, debug) {
          <span class="keyword">if</span> (err) {</pre></div></div>
            
        </li>
        
        
        <li id="section-124">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-124">&#182;</a>
              </div>
              <p>we ignore entity not found exception and return a null instead</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (err.exception === <span class="string">'EntityNotFoundException'</span>)
              <span class="keyword">return</span> cb(<span class="literal">null</span>, <span class="literal">null</span>, debug);
            <span class="keyword">else</span>
              <span class="keyword">return</span> cb(err, result, debug);
          }
          <span class="keyword">var</span> node = result[<span class="number">0</span>][<span class="number">0</span>];
          <span class="keyword">var</span> labels = result[<span class="number">0</span>][<span class="number">1</span>];
          node.setLabels(labels);
          <span class="keyword">if</span> ((<span class="keyword">typeof</span> self.load === <span class="string">'function'</span>) &amp;&amp; (<span class="keyword">typeof</span> node.load === <span class="string">'function'</span>))
            node.load(cb, debug);
          <span class="keyword">else</span>
            cb(<span class="literal">null</span>, node, debug);
        });
      <span class="keyword">return</span> <span class="keyword">this</span>;
    } <span class="keyword">else</span> {
      self.cypher.by_id = Number(id);
      <span class="keyword">return</span> self.findByKeyValue({ id: id }, cb);
    }
  }

  Node.prototype.findByKeyValue = <span class="keyword">function</span>(key, value, cb, _limit_) {
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="keyword">if</span> (<span class="keyword">typeof</span> _limit_ === <span class="string">'undefined'</span>)
      _limit_ = <span class="literal">null</span>;
    <span class="keyword">if</span> (!self._is_singleton_)
      self = <span class="keyword">this</span>.singleton(<span class="literal">undefined</span>, <span class="keyword">this</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-125">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-125">&#182;</a>
              </div>
              <p>we have s.th. like
{ key: value }</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (<span class="keyword">typeof</span> key === <span class="string">'object'</span>) {
      cb = value;
      <span class="keyword">var</span> _key = Object.keys(key)[<span class="number">0</span>];
      value = key[_key];
      key = _key;
    }

    <span class="keyword">if</span> (<span class="keyword">typeof</span> key !== <span class="string">'string'</span>)
      key = <span class="string">'id'</span>;
    <span class="keyword">if</span> ( (_.isString(key)) &amp;&amp; (<span class="keyword">typeof</span> value !== <span class="string">'undefined'</span>) ) {
      self._query_history_.push({ findByKeyValue: <span class="literal">true</span> });
      <span class="keyword">var</span> identifier = self.cypher.node_identifier || self.__TYPE_IDENTIFIER__;
      <span class="keyword">if</span> (self.cypher.return_properties.length === <span class="number">0</span>)
        self.cypher.return_properties = [ identifier ];
      <span class="keyword">if</span> (key !== <span class="string">'id'</span>) {
        <span class="keyword">var</span> query = {};
        query[key] = value;
        self.where(query);
        <span class="keyword">if</span> (self.label) self.withLabel(self.label);</pre></div></div>
            
        </li>
        
        
        <li id="section-126">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-126">&#182;</a>
              </div>
              <p>if we have an id: value, we will build the query in prepareQuery</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      }
      <span class="keyword">if</span> (<span class="keyword">typeof</span> cb === <span class="string">'function'</span>) {
        <span class="keyword">return</span> self.exec(<span class="keyword">function</span>(err,found){
          <span class="keyword">if</span> (err)
            <span class="keyword">return</span> cb(err, found);
          <span class="keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-127">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-127">&#182;</a>
              </div>
              <p>try to return the first (if exists)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (found === <span class="literal">null</span>)
              <span class="keyword">return</span> cb(<span class="literal">null</span>, found);
            <span class="keyword">else</span> <span class="keyword">if</span> (found.length === <span class="number">0</span>)
              found = <span class="literal">null</span>;
            <span class="keyword">else</span> <span class="keyword">if</span> ((found.length === <span class="number">1</span>) &amp;&amp; ( <span class="number">1</span> === _limit_))
              found = found[<span class="number">0</span>];
            <span class="keyword">else</span> <span class="keyword">if</span> ((_limit_ &gt; <span class="number">1</span>) &amp;&amp; (found.length &gt; _limit_))</pre></div></div>
            
        </li>
        
        
        <li id="section-128">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-128">&#182;</a>
              </div>
              <p>TODO: use a cypher limit instead</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              found = found.splice(<span class="number">0</span>, _limit_);
            <span class="keyword">return</span> cb(<span class="literal">null</span>, found);
          }
        });
      }

    }
    <span class="keyword">return</span> self;
  }

  Node.prototype.findOneByKeyValue = <span class="keyword">function</span>(key, value, cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.findByKeyValue(key, value, cb, <span class="number">1</span>);
  }

  Node.prototype.findAll = <span class="keyword">function</span>(cb) {
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="keyword">if</span> (!self._is_singleton_)
      self = <span class="keyword">this</span>.singleton(<span class="literal">undefined</span>, <span class="keyword">this</span>);
    self._query_history_.push({ findAll: <span class="literal">true</span> });
    self.cypher.limit = <span class="literal">null</span>;
    self.cypher.return_properties = [<span class="string">'n'</span>];
    <span class="keyword">if</span> (self.label) self.withLabel(self.label);
    <span class="keyword">return</span> self.exec(cb);
  }

  Node.prototype.findOrCreate = <span class="keyword">function</span>(where, cb) {
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="keyword">this</span>.find(where).count(<span class="keyword">function</span>(err, count, debug) {
      <span class="keyword">if</span> (err)
        <span class="keyword">return</span> cb(err, count, debug);
      <span class="keyword">else</span> {
        <span class="keyword">if</span> (count === <span class="number">1</span>)
          <span class="keyword">return</span> self.findOne(where, cb);
        <span class="keyword">else</span> <span class="keyword">if</span> (count &gt; <span class="number">1</span>)
          <span class="keyword">return</span> cb(Error(<span class="string">"More than one node found… You have query one distinct result"</span>), <span class="literal">null</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-129">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-129">&#182;</a>
              </div>
              <p>else</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> node = <span class="keyword">new</span> self.constructor(where);
        node.save(cb);
      }
    });
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  <span class="comment">/*
   * Singleton methods, shorthands for their corresponding (static) prototype methods
   */</span>

  Node.singleton = <span class="keyword">function</span>(id, label) {
    <span class="keyword">return</span> <span class="keyword">this</span>.prototype.singleton(id, label);
  }

  Node.find = <span class="keyword">function</span>(where, cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.prototype.find(where, cb);
  }

  Node.findAll = <span class="keyword">function</span>(cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.prototype.findAll(cb);
  }

  Node.findById = <span class="keyword">function</span>(id, cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.prototype.findById(id, cb);
  }

  Node.findOne = <span class="keyword">function</span>(where, cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.prototype.findOne(where, cb);
  }

  Node.find = <span class="keyword">function</span>(where, cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.prototype.find(where, cb);
  }

  Node.findOrCreate = <span class="keyword">function</span>(where, cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.prototype.findOrCreate(where, cb);
  }

  Node.findByKeyValue = <span class="keyword">function</span>(key, value, cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.prototype.findByKeyValue(key, value, cb);
  }

  Node.findOneByKeyValue = <span class="keyword">function</span>(key, value, cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.prototype.findOneByKeyValue(key, value, cb);
  }

  Node.start = <span class="keyword">function</span>(start, cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.prototype.start(start, cb);
  }

  Node.query = <span class="keyword">function</span>(cypherQuery, options, cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.prototype.singleton().query(cypherQuery, options, cb);
  }

  Node.registerModel = <span class="keyword">function</span>(Class, label, prototype, cb) {
    <span class="keyword">var</span> name = <span class="literal">null</span>
      , ParentModel = <span class="keyword">this</span>;

    <span class="keyword">if</span> (<span class="keyword">typeof</span> Class === <span class="string">'string'</span>) {

      <span class="keyword">if</span> (<span class="keyword">typeof</span> label === <span class="string">'function'</span>) {
        cb = label;
        prototype = {};
      } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> label === <span class="string">'object'</span>) {
        cb = prototype;
        prototype = label;
        label = <span class="literal">null</span>;
      } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> prototype === <span class="string">'function'</span>) {
        cb = prototype;
        prototype = {};
      }
      <span class="keyword">if</span> (<span class="keyword">typeof</span> prototype !== <span class="string">'object'</span>)
        prototype = {};
      label = name = Class;</pre></div></div>
            
        </li>
        
        
        <li id="section-130">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-130">&#182;</a>
              </div>
              <p>we define here an anonymous constructor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      Class = <span class="keyword">function</span>() {
        <span class="keyword">this</span>.init.apply(<span class="keyword">this</span>, arguments);
        <span class="keyword">if</span> (Class.prototype.label === <span class="literal">null</span>)
          <span class="keyword">this</span>.label = <span class="keyword">this</span>._constructor_name_ = label;
        <span class="keyword">else</span>
          <span class="keyword">this</span>.label = <span class="keyword">this</span>._constructor_name_ = Class.prototype.label;
      }

      _.extend(Class, ParentModel); <span class="comment">// 'static' methods</span>

      <span class="keyword">if</span> (prototype) {
        _.extend(Class.prototype, ParentModel.prototype, prototype);
        <span class="keyword">if</span> (prototype.fields) {</pre></div></div>
            
        </li>
        
        
        <li id="section-131">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-131">&#182;</a>
              </div>
              <p>extend each field defintion on prototype
e.g. indexes, defaults…</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="keyword">var</span> fieldDefinitions = prototype.fields;</pre></div></div>
            
        </li>
        
        
        <li id="section-132">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-132">&#182;</a>
              </div>
              <p>fields will be extended seperately</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          Class.prototype.fields = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-133">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-133">&#182;</a>
              </div>
              <p>iterate and extend through defaults, indexes, unique …</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="keyword">for</span> (<span class="keyword">var</span> attribute <span class="keyword">in</span> { indexes: {}, defaults: {},  unique: {} }) {
            <span class="keyword">if</span> ((ParentModel.prototype.fields)&amp;&amp;(ParentModel.prototype.fields[attribute]))
              Class.prototype.fields[attribute] = _.extend({}, ParentModel.prototype.fields[attribute], fieldDefinitions[attribute] || {});
          }
        }
      }

      <span class="keyword">if</span> (!Class.prototype.labels)
        Class.prototype.labels = [];
      <span class="keyword">else</span></pre></div></div>
            
        </li>
        
        
        <li id="section-134">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-134">&#182;</a>
              </div>
              <p>copy (inherited) labels from parent class</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        Class.prototype.labels = ParentModel.prototype.labels.slice();

      Class.prototype.labels.unshift(label);

    } <span class="keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-135">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-135">&#182;</a>
              </div>
              <p>we expect to have a <code>class</code>-object as known from CoffeeScript</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      Class.prototype.labels = Class.getParentModels();
      <span class="keyword">if</span> (<span class="keyword">typeof</span> label === <span class="string">'string'</span>) {
        name = label;
      } <span class="keyword">else</span> {
        name = helpers.constructorNameOfFunction(Class);
        cb = label;
      }
    }
    Node.__models__[name] = Class;
    Class.prototype.initialize(cb);
    <span class="keyword">return</span> Class;
  }

  Node.getParentModels = <span class="keyword">function</span>() {
    <span class="keyword">var</span> models = [];
    models.push(helpers.constructorNameOfFunction(<span class="keyword">this</span>));
    <span class="keyword">if</span> (<span class="keyword">this</span>.__super__) {
      <span class="keyword">var</span> Class = <span class="keyword">this</span>;
      <span class="keyword">var</span> i = <span class="number">0</span>;
      <span class="keyword">var</span> modelName = <span class="string">''</span>;
      <span class="keyword">while</span>((Class.__super__) &amp;&amp; (i &lt; <span class="number">10</span>)) {
        i++;
        modelName = helpers.constructorNameOfFunction(Class.__super__);

        <span class="keyword">if</span> (!<span class="regexp">/^(Node|Relationship|Path)/</span>.test(modelName))
          models.push(modelName);
        <span class="keyword">if</span> ((Class.prototype.labels)&amp;&amp;(Class.prototype.labels.length &gt; <span class="number">0</span>))
          models.push(Class.prototype.labels);
        Class = Class.__super__;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-136">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-136">&#182;</a>
              </div>
              <p>we have a &quot;coffeescript class&quot; object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    }
    <span class="keyword">return</span> _.uniq(_.flatten(models));
  }

  Node.unregisterModel = <span class="keyword">function</span>(Class) {
    <span class="keyword">var</span> name = (<span class="keyword">typeof</span> Class === <span class="string">'string'</span>) ? Class : helpers.constructorNameOfFunction(Class);
    <span class="keyword">if</span> (<span class="keyword">typeof</span> Node.__models__[name] === <span class="string">'function'</span>)
      <span class="keyword">delete</span> Node.__models__[name];
    <span class="keyword">return</span> Node.__models__;
  }

  Node.registeredModels = <span class="keyword">function</span>() {
    <span class="keyword">return</span> Node.__models__;
  }

  Node.registeredModel = <span class="keyword">function</span>(model) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> model === <span class="string">'function'</span>) {
      model = helpers.constructorNameOfFunction(model);
    }
    <span class="keyword">return</span> Node.registered_models()[model] || <span class="literal">null</span>;
  }

  Node.convertNodeToModel = <span class="keyword">function</span>(node, model, fallbackModel) {
    <span class="keyword">return</span> <span class="keyword">this</span>.prototype.convertNodeToModel(node, model, fallbackModel);
  }

  Node.ensureIndex = <span class="keyword">function</span>(cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.singleton().ensureIndex(cb);
  }

  Node.dropIndex = <span class="keyword">function</span>(fields, cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.singleton().dropIndex(fields, cb);
  }

  Node.dropEntireIndex = <span class="keyword">function</span>(cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.singleton().dropEntireIndex(cb);
  }

  Node.getIndex = <span class="keyword">function</span>(cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.singleton().getIndex(cb);
  }

  Node.disableLoading = <span class="keyword">function</span>() {
    <span class="keyword">return</span> <span class="keyword">this</span>.prototype.disableLoading();
  }

  Node.enableLoading = <span class="keyword">function</span>() {
    <span class="keyword">return</span> <span class="keyword">this</span>.prototype.enableLoading();
  }

  Node.deleteAllIncludingRelations = <span class="keyword">function</span>(cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.find().deleteIncludingRelations(cb);
  }

  Node.create = <span class="keyword">function</span>(data, id) {
    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>(data, id);
  }

  Node.registered_model   = Node.registeredModel;
  Node.registered_models  = Node.registeredModels;
  Node.unregister_model   = Node.unregisterModel;
  Node.register_model     = Node.registerModel;</pre></div></div>
            
        </li>
        
        
        <li id="section-137">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-137">&#182;</a>
              </div>
              <p>only once</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> ((<span class="keyword">typeof</span> Graph.prototype === <span class="string">'object'</span>) &amp;&amp; (!Node.prototype._addParametersToCypher)) {
    Node.prototype._addParametersToCypher         = Graph.prototype._addParametersToCypher;
    Node.prototype._addParameterToCypher          = Graph.prototype._addParameterToCypher;
  }

  <span class="keyword">return</span> neo4jrestful.Node = Node;
}

<span class="keyword">if</span> (<span class="keyword">typeof</span> window !== <span class="string">'object'</span>) {
  module.exports = exports = {
    init: __initNode__
  }
} <span class="keyword">else</span> {
  window.Neo4jMapper.initNode = __initNode__;
}</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
